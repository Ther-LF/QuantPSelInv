<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PEXSI: PEXSI::PPEXSIData Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://math.berkeley.edu/~linlin/MathJax-2.6/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PEXSI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_p_e_x_s_i.html">PEXSI</a></li><li class="navelem"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html">PPEXSIData</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PEXSI::PPEXSIData Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main class for parallel PEXSI.  
 <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ppexsi_8hpp_source.html">ppexsi.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0274cd36b7bf7b6a24b654d79d12ec2"><td class="memItemLeft" align="right" valign="top"><a id="ab0274cd36b7bf7b6a24b654d79d12ec2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PPEXSIData</b> (MPI_Comm comm, Int numProcRow, Int numProcCol, Int outputFileIndex)</td></tr>
<tr class="separator:ab0274cd36b7bf7b6a24b654d79d12ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096a9f61fbb8b42f797ed1b462b75207"><td class="memItemLeft" align="right" valign="top"><a id="a096a9f61fbb8b42f797ed1b462b75207"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadRealMatrix</b> (Int nrows, Int nnz, Int nnzLocal, Int numColLocal, Int *colptrLocal, Int *rowindLocal, Real *HnzvalLocal, Int isSIdentity, Real *SnzvalLocal, Int solver, Int verbosity)</td></tr>
<tr class="separator:a096a9f61fbb8b42f797ed1b462b75207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30feae65a13e64145dfdd3ea586c4d1a"><td class="memItemLeft" align="right" valign="top"><a id="a30feae65a13e64145dfdd3ea586c4d1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>LoadComplexMatrix</b> (Int nrows, Int nnz, Int nnzLocal, Int numColLocal, Int *colptrLocal, Int *rowindLocal, Complex *HnzvalLocal, Int isSIdentity, Complex *SnzvalLocal, Int solver, Int verbosity)</td></tr>
<tr class="separator:a30feae65a13e64145dfdd3ea586c4d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5cb0eee28b63f26e886460643712d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a5a5cb0eee28b63f26e886460643712d0">SymbolicFactorizeRealSymmetricMatrix</a> (Int solver, Int symmetricStorage, std::string ColPerm, Int numProcSymbFact, Int verbosity)</td></tr>
<tr class="memdesc:a5a5cb0eee28b63f26e886460643712d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolically factorize the loaded matrices for real arithmetic factorization and selected inversion.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a5a5cb0eee28b63f26e886460643712d0">More...</a><br /></td></tr>
<tr class="separator:a5a5cb0eee28b63f26e886460643712d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb33d026b4dfead14fec7c33bedd735e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#abb33d026b4dfead14fec7c33bedd735e">SymbolicFactorizeRealUnsymmetricMatrix</a> (Int solver, std::string ColPerm, std::string RowPerm, Int numProcSymbFact, Int Transpose, double *AnzvalLocal, Int verbosity)</td></tr>
<tr class="memdesc:abb33d026b4dfead14fec7c33bedd735e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolically factorize the loaded matrices for real arithmetic factorization and selected inversion.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#abb33d026b4dfead14fec7c33bedd735e">More...</a><br /></td></tr>
<tr class="separator:abb33d026b4dfead14fec7c33bedd735e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be01e7f1a5837becba789e9ca89ef2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a8be01e7f1a5837becba789e9ca89ef2c">SymbolicFactorizeComplexSymmetricMatrix</a> (Int solver, Int symmetricStorage, std::string ColPerm, Int numProcSymbFact, Int verbosity)</td></tr>
<tr class="memdesc:a8be01e7f1a5837becba789e9ca89ef2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolically factorize the loaded matrices for complex arithmetic factorization and selected inversion.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a8be01e7f1a5837becba789e9ca89ef2c">More...</a><br /></td></tr>
<tr class="separator:a8be01e7f1a5837becba789e9ca89ef2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06f6bad026eabc56862d9010c0c93bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#ad06f6bad026eabc56862d9010c0c93bb">SymbolicFactorizeComplexUnsymmetricMatrix</a> (Int solver, std::string ColPerm, std::string RowPerm, Int numProcSymbFact, Int Transpose, double *AnzvalLocal, Int verbosity)</td></tr>
<tr class="memdesc:ad06f6bad026eabc56862d9010c0c93bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolically factorize the loaded matrices for complex arithmetic factorization and selected inversion.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#ad06f6bad026eabc56862d9010c0c93bb">More...</a><br /></td></tr>
<tr class="separator:ad06f6bad026eabc56862d9010c0c93bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de4e9c5f1ac5939675517a24a5944c6"><td class="memItemLeft" align="right" valign="top"><a id="a3de4e9c5f1ac5939675517a24a5944c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SelInvRealSymmetricMatrix</b> (Int solver, Int symmetricStorage, double *AnzvalLocal, Int verbosity, double *AinvnzvalLocal)</td></tr>
<tr class="separator:a3de4e9c5f1ac5939675517a24a5944c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c85b682aa8e0a64b0d74c52d095ff6"><td class="memItemLeft" align="right" valign="top"><a id="a89c85b682aa8e0a64b0d74c52d095ff6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SelInvRealUnsymmetricMatrix</b> (Int solver, double *AnzvalLocal, Int verbosity, double *AinvnzvalLocal)</td></tr>
<tr class="separator:a89c85b682aa8e0a64b0d74c52d095ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca920dfc01dd3d586085a4eaea85e71c"><td class="memItemLeft" align="right" valign="top"><a id="aca920dfc01dd3d586085a4eaea85e71c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SelInvComplexSymmetricMatrix</b> (Int solver, Int symmetricStorage, double *AnzvalLocal, Int verbosity, double *AinvnzvalLocal)</td></tr>
<tr class="separator:aca920dfc01dd3d586085a4eaea85e71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc4ba4ef8a6ee39d75cb82dc91862c9"><td class="memItemLeft" align="right" valign="top"><a id="aebc4ba4ef8a6ee39d75cb82dc91862c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SelInvComplexUnsymmetricMatrix</b> (Int solver, double *AnzvalLocal, Int verbosity, double *AinvnzvalLocal)</td></tr>
<tr class="separator:aebc4ba4ef8a6ee39d75cb82dc91862c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c0c46d2ab48c5fd722dcf1e1f4e76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a58c0c46d2ab48c5fd722dcf1e1f4e76a">CalculateNegativeInertiaReal</a> (const std::vector&lt; Real &gt; &amp;shiftVec, std::vector&lt; Real &gt; &amp;inertiaVec, Int solver, Int verbosity)</td></tr>
<tr class="memdesc:a58c0c46d2ab48c5fd722dcf1e1f4e76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the negative inertia (the number of eigenvalues below a shift) for real symmetric matrices. The factorization uses real arithemetic factorization routine.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a58c0c46d2ab48c5fd722dcf1e1f4e76a">More...</a><br /></td></tr>
<tr class="separator:a58c0c46d2ab48c5fd722dcf1e1f4e76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5c7c1f73eb8d0dd38fc764357faea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#aad5c7c1f73eb8d0dd38fc764357faea9">CalculateNegativeInertiaComplex</a> (const std::vector&lt; Real &gt; &amp;shiftVec, std::vector&lt; Real &gt; &amp;inertiaVec, Int solver, Int verbosity)</td></tr>
<tr class="memdesc:aad5c7c1f73eb8d0dd38fc764357faea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the negative inertia (the number of eigenvalues below a shift) for complex Hermitian matrices. Currently this is performed with LU factorization without row permutation.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#aad5c7c1f73eb8d0dd38fc764357faea9">More...</a><br /></td></tr>
<tr class="separator:aad5c7c1f73eb8d0dd38fc764357faea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115b5fa2acc182926bb9db9ad870aad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a115b5fa2acc182926bb9db9ad870aad4">CalculateFermiOperatorReal</a> (Int numPole, Real temperature, Real gap, Real deltaE, Real mu, Real numElectronExact, Real numElectronTolerance, Int solver, Int verbosity, Real &amp;numElectron, Real &amp;numElectronDrvMu)</td></tr>
<tr class="memdesc:a115b5fa2acc182926bb9db9ad870aad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Fermi operator for a given chemical potential for real symmetric matrices.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a115b5fa2acc182926bb9db9ad870aad4">More...</a><br /></td></tr>
<tr class="separator:a115b5fa2acc182926bb9db9ad870aad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8787de5d9d82115e676dfd3a2a7f4dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a8787de5d9d82115e676dfd3a2a7f4dcb">CalculateFermiOperatorComplex</a> (Int numPole, Real temperature, Real gap, Real deltaE, Real mu, Real numElectronExact, Real numElectronTolerance, Int solver, Int verbosity, Real &amp;numElectron, Real &amp;numElectronDrvMu, Int method, Int nPoints, Real spin)</td></tr>
<tr class="memdesc:a8787de5d9d82115e676dfd3a2a7f4dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Fermi operator for a given chemical potential for Hermitian Hamiltonian and overlap matrices.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a8787de5d9d82115e676dfd3a2a7f4dcb">More...</a><br /></td></tr>
<tr class="separator:a8787de5d9d82115e676dfd3a2a7f4dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfa4c5c534f4605ccf68c4ba2fa8b89"><td class="memItemLeft" align="right" valign="top"><a id="aecfa4c5c534f4605ccf68c4ba2fa8b89"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#aecfa4c5c534f4605ccf68c4ba2fa8b89">DFTDriver</a> (Real numElectronExact, Real temperature, Real gap, Real deltaE, Int numPole, Int isInertiaCount, Int maxPEXSIIter, Real muMin0, Real muMax0, Real mu0, Real muInertiaTolerance, Real muInertiaExpansion, Real muPEXSISafeGuard, Real numElectronPEXSITolerance, Int matrixType, Int isSymbolicFactorize, Int solver, Int symmetricStorage, Int ordering, Int numProcSymbFact, Int verbosity, Real &amp;muPEXSI, Real &amp;numElectronPEXSI, Real &amp;muMinInertia, Real &amp;muMaxInertia, Int &amp;numTotalInertiaIter, Int &amp;numTotalPEXSIIter)</td></tr>
<tr class="memdesc:aecfa4c5c534f4605ccf68c4ba2fa8b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main driver for solving KSDFT. <br /></td></tr>
<tr class="separator:aecfa4c5c534f4605ccf68c4ba2fa8b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc623f5a5d10afe5070366dbaa90706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#acdc623f5a5d10afe5070366dbaa90706">CalculateFermiOperatorReal3</a> (Int numPole, Real temperature, Real gap, Real deltaE, Real numElectronExact, Real numElectronTolerance, Int solver, Int verbosity, Real &amp;mu, Real &amp;numElectron, Int method, Int nPoints, Real spin)</td></tr>
<tr class="memdesc:acdc623f5a5d10afe5070366dbaa90706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Fermi operator and derivied quantities.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#acdc623f5a5d10afe5070366dbaa90706">More...</a><br /></td></tr>
<tr class="separator:acdc623f5a5d10afe5070366dbaa90706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81202d21e3d67ad5f916a4afaed0e24a"><td class="memItemLeft" align="right" valign="top"><a id="a81202d21e3d67ad5f916a4afaed0e24a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a81202d21e3d67ad5f916a4afaed0e24a">CalculateEDMCorrectionReal</a> (Int numPole, Int solver, Int verbosity, Int nPoints, Real spin)</td></tr>
<tr class="memdesc:a81202d21e3d67ad5f916a4afaed0e24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Correction of the EDM matrix. <br /></td></tr>
<tr class="separator:a81202d21e3d67ad5f916a4afaed0e24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf809c346705efe249dba674622ccee3"><td class="memItemLeft" align="right" valign="top"><a id="aaf809c346705efe249dba674622ccee3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#aaf809c346705efe249dba674622ccee3">CalculateEDMCorrectionComplex</a> (Int numPole, Int solver, Int verbosity, Int nPoints, Real spin)</td></tr>
<tr class="memdesc:aaf809c346705efe249dba674622ccee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Correction of the EDM matrix. <br /></td></tr>
<tr class="separator:aaf809c346705efe249dba674622ccee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfc8a0eb20d7c45e3e97324eea33f26"><td class="memItemLeft" align="right" valign="top"><a id="accfc8a0eb20d7c45e3e97324eea33f26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#accfc8a0eb20d7c45e3e97324eea33f26">DFTDriver2</a> (Real numElectronExact, Real temperature, Real gap, Real deltaE, Int numPole, Real muInertiaTolerance, Real numElectronPEXSITolerance, Int matrixType, Int isSymbolicFactorize, Int solver, Int symmetricStorage, Int ordering, Int numProcSymbFact, Int verbosity, Real &amp;muPEXSI, Real &amp;numElectronPEXSI, Real &amp;muMinInertia, Real &amp;muMaxInertia, Int &amp;numTotalInertiaIter, Int method, Int nPoints, Real spin)</td></tr>
<tr class="memdesc:accfc8a0eb20d7c45e3e97324eea33f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updated main driver for DFT. This reuses the pole expansion and only performs one <a class="el" href="namespace_p_e_x_s_i.html" title="The main namespace.">PEXSI</a> iteration per SCF step. <br /></td></tr>
<tr class="separator:accfc8a0eb20d7c45e3e97324eea33f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf344da2e8f7bfdc8d436f75dcd5ce2"><td class="memItemLeft" align="right" valign="top"><a id="a3bf344da2e8f7bfdc8d436f75dcd5ce2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a3bf344da2e8f7bfdc8d436f75dcd5ce2">InterpolateDMReal</a> (Real numElectronExact, Real numElectronPEXSI, Real numElectronPEXSITolerance, Int nPoints, Real *NeVec, Real &amp;muMin, Real &amp;muMax, Real &amp;muPEXSI, Int &amp;iFLAG, Int method, Int verbosity)</td></tr>
<tr class="memdesc:a3bf344da2e8f7bfdc8d436f75dcd5ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the DM and get the total Energy. <br /></td></tr>
<tr class="separator:a3bf344da2e8f7bfdc8d436f75dcd5ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeceb5c9d51fb66bdb1afc71374655368"><td class="memItemLeft" align="right" valign="top"><a id="aeceb5c9d51fb66bdb1afc71374655368"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#aeceb5c9d51fb66bdb1afc71374655368">InterpolateDMComplex</a> (Real numElectronExact, Real numElectronPEXSI, Real numElectronPEXSITolerance, Int nPoints, Real *NeVec, Real &amp;muMin, Real &amp;muMax, Real &amp;muPEXSI, Int &amp;iFLAG, Int method, Int verbosity)</td></tr>
<tr class="memdesc:aeceb5c9d51fb66bdb1afc71374655368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate the DM and get the total Energy. <br /></td></tr>
<tr class="separator:aeceb5c9d51fb66bdb1afc71374655368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ebf0c9d98b47c3e6ec3490ce86bc4d"><td class="memItemLeft" align="right" valign="top"><a id="aa2ebf0c9d98b47c3e6ec3490ce86bc4d"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_grid_type.html">GridType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GridPole</b> () const</td></tr>
<tr class="separator:aa2ebf0c9d98b47c3e6ec3490ce86bc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a35368db40989fd4fc85919121aae13"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; Real &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a2a35368db40989fd4fc85919121aae13">RhoRealMat</a> () const</td></tr>
<tr class="memdesc:a2a35368db40989fd4fc85919121aae13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Density matrix.  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a2a35368db40989fd4fc85919121aae13">More...</a><br /></td></tr>
<tr class="separator:a2a35368db40989fd4fc85919121aae13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d2e5937a01c9ff5eb2ac1ec0696b25"><td class="memItemLeft" align="right" valign="top"><a id="ac1d2e5937a01c9ff5eb2ac1ec0696b25"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; Complex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RhoComplexMat</b> () const</td></tr>
<tr class="separator:ac1d2e5937a01c9ff5eb2ac1ec0696b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad280cf7310af70b99ae90d08ed4b9eac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; Real &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#ad280cf7310af70b99ae90d08ed4b9eac">EnergyDensityRealMat</a> () const</td></tr>
<tr class="memdesc:ad280cf7310af70b99ae90d08ed4b9eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Energy density matrix. <br  />
  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#ad280cf7310af70b99ae90d08ed4b9eac">More...</a><br /></td></tr>
<tr class="separator:ad280cf7310af70b99ae90d08ed4b9eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d94fc8418b14963091417e7925c652"><td class="memItemLeft" align="right" valign="top"><a id="a99d94fc8418b14963091417e7925c652"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; Complex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>EnergyDensityComplexMat</b> () const</td></tr>
<tr class="separator:a99d94fc8418b14963091417e7925c652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136cd30bdca8b6cb68ac3bb6eb8bef40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; Real &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a136cd30bdca8b6cb68ac3bb6eb8bef40">FreeEnergyDensityRealMat</a> () const</td></tr>
<tr class="memdesc:a136cd30bdca8b6cb68ac3bb6eb8bef40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total Helmholtz free energy matrix (band energy part only). <br  />
  <a href="class_p_e_x_s_i_1_1_p_p_e_x_s_i_data.html#a136cd30bdca8b6cb68ac3bb6eb8bef40">More...</a><br /></td></tr>
<tr class="separator:a136cd30bdca8b6cb68ac3bb6eb8bef40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f03b29f1e4cfcf064b9952899d4ada"><td class="memItemLeft" align="right" valign="top"><a id="a71f03b29f1e4cfcf064b9952899d4ada"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; Complex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>FreeEnergyDensityComplexMat</b> () const</td></tr>
<tr class="separator:a71f03b29f1e4cfcf064b9952899d4ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1b39d1b0a7d011a08f22e3bdb01b20"><td class="memItemLeft" align="right" valign="top"><a id="a2d1b39d1b0a7d011a08f22e3bdb01b20"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><b>TotalEnergyH</b> () const</td></tr>
<tr class="separator:a2d1b39d1b0a7d011a08f22e3bdb01b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc56ab44641000aa0300dca8fd27b7f"><td class="memItemLeft" align="right" valign="top"><a id="a1dc56ab44641000aa0300dca8fd27b7f"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><b>TotalEnergyS</b> () const</td></tr>
<tr class="separator:a1dc56ab44641000aa0300dca8fd27b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47a6aeedb9dbd8058e614c894a4d3f2"><td class="memItemLeft" align="right" valign="top"><a id="ad47a6aeedb9dbd8058e614c894a4d3f2"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><b>TotalFreeEnergy</b> () const</td></tr>
<tr class="separator:ad47a6aeedb9dbd8058e614c894a4d3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main class for parallel PEXSI. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8787de5d9d82115e676dfd3a2a7f4dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8787de5d9d82115e676dfd3a2a7f4dcb">&#9670;&nbsp;</a></span>CalculateFermiOperatorComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PPEXSIData::CalculateFermiOperatorComplex </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>numPole</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>temperature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>deltaE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>numElectronExact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>numElectronTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>numElectron</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>numElectronDrvMu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>spin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Fermi operator for a given chemical potential for Hermitian Hamiltonian and overlap matrices. </p>
<p>This routine also computes the single particle density matrix, the Helmholtz free energy density matrix, and the energy density matrix (for computing the Pulay force) simultaneously. These matrices can be called later via member functions DensityMatrix, FreeEnergyDensityMatrix, EnergyDensityMatrix.</p>
<p>NOTE: One should pay some special attention to the treatment of the Hermitian case.</p>
<ol type="1">
<li>Since the pole locations and weights appear in conjugate pairs (z_l,w_l) and (conj(z_l),conj(w_l)), we do not compute the conjugate pairs explicitly. In the real symmetric case, after computing the density matrix rhoMat, we only need to take its imaginary component Im(rhoMat) to obtain the correct density matrix. In the Hermitian case, this is replaced by rhoMat &lt;- 1/(2i) (rhoMat - rhoMat^*) where rhoMat^* is the Hermitian transpose.</li>
<li>The Hermitian case calls the non-symmetric version of PSelInv. This returns the transpose of rhoMat. Since rhoMat is Hermitian, we can store the correct rhoMat by applying a conjugation operation due to the following relation.</li>
</ol>
<p>rhoMat = rhoMat^* = conj(rhoMat^T)</p>
<ol type="1">
<li><p class="startli">Combining 1) and 2) above, the correct density matrix can be obtained by</p>
<p class="startli">rhoMat &lt;- i/2 (conj(rhoMat) - rhoMat^T)</p>
</li>
</ol>
<p>The same post processing strategy should be applied to other quantities such as the energy density matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numPole</td><td>Number of poles for the pole expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temperature</td><td>Temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap</td><td>Band gap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deltaE</td><td>Upperbound of the spectrum width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>Initial guess of chemical potential. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElectronExact</td><td>Exact number of electrons. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElectronTolerance</td><td>Tolerance for the number of electrons. This is just used to discard some poles in the pole expansion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>The level of output information.<ul>
<li>= 0 : No output.</li>
<li>= 1 : Basic output (default)</li>
<li>= 2 : Detailed output. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numElectron</td><td>The number of electron calculated at mu. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numElectronDrvMu</td><td>The derivative of the number of electron calculated with respect to the chemical potential at mu. </td></tr>
  </table>
  </dd>
</dl>
<p>test the getPole function. actually, NumPole should be get from here.</p>

</div>
</div>
<a id="a115b5fa2acc182926bb9db9ad870aad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115b5fa2acc182926bb9db9ad870aad4">&#9670;&nbsp;</a></span>CalculateFermiOperatorReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PPEXSIData::CalculateFermiOperatorReal </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>numPole</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>temperature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>deltaE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>numElectronExact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>numElectronTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>numElectron</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>numElectronDrvMu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Fermi operator for a given chemical potential for real symmetric matrices. </p>
<p>This routine also computes the single particle density matrix, the Helmholtz free energy density matrix, and the energy density matrix (for computing the Pulay force) simultaneously. These matrices can be called later via member functions DensityMatrix, FreeEnergyDensityMatrix, EnergyDensityMatrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numPole</td><td>Number of poles for the pole expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temperature</td><td>Temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap</td><td>Band gap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deltaE</td><td>Upperbound of the spectrum width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>Initial guess of chemical potential. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElectronExact</td><td>Exact number of electrons. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElectronTolerance</td><td>Tolerance for the number of electrons. This is just used to discard some poles in the pole expansion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>The level of output information.<ul>
<li>= 0 : No output.</li>
<li>= 1 : Basic output (default)</li>
<li>= 2 : Detailed output. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numElectron</td><td>The number of electron calculated at mu. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numElectronDrvMu</td><td>The derivative of the number of electron calculated with respect to the chemical potential at mu. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdc623f5a5d10afe5070366dbaa90706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc623f5a5d10afe5070366dbaa90706">&#9670;&nbsp;</a></span>CalculateFermiOperatorReal3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PPEXSIData::CalculateFermiOperatorReal3 </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>numPole</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>temperature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>deltaE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>numElectronExact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>numElectronTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;&#160;</td>
          <td class="paramname"><em>numElectron</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real&#160;</td>
          <td class="paramname"><em>spin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Fermi operator and derivied quantities. </p>
<p>This routine also updates the chemical potential mu by reusing Green's functions but with updated contour.</p>
<p>This routine also computes the single particle density matrix, the Helmholtz free energy density matrix, and the energy density matrix (for computing the Pulay force) simultaneously. These matrices can be called later via member functions DensityMatrix, FreeEnergyDensityMatrix, EnergyDensityMatrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numPole</td><td>Number of poles for the pole expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temperature</td><td>Temperature </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap</td><td>Band gap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deltaE</td><td>Upperbound of the spectrum width </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElectronExact</td><td>Exact number of electrons. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElectronTolerance</td><td>Tolerance for the number of electrons. This is just used to discard some poles in the pole expansion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">muMinPEXSI</td><td>Minimum of the interval for searching mu. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">muMaxPEXSI</td><td>Maximum of the interval for searching mu. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>The level of output information.<ul>
<li>= 0 : No output.</li>
<li>= 1 : Basic output (default)</li>
<li>= 2 : Detailed output. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>Initial guess of chemical potential. On return it gives the updated chemical potential within the range of [muMinPEXSI, muMaxPEXSI] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numElectron</td><td>The number of electron calculated at mu. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isConverged</td><td>Whether the update strategy for finding the chemical potential has converged. </td></tr>
  </table>
  </dd>
</dl>
<p>test the getPole function. actually, NumPole should be get from here.</p>

</div>
</div>
<a id="aad5c7c1f73eb8d0dd38fc764357faea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5c7c1f73eb8d0dd38fc764357faea9">&#9670;&nbsp;</a></span>CalculateNegativeInertiaComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PPEXSIData::CalculateNegativeInertiaComplex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>shiftVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertiaVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the negative inertia (the number of eigenvalues below a shift) for complex Hermitian matrices. Currently this is performed with LU factorization without row permutation. </p>
<p>This subroutine computes the negative inertia of the matrix</p>
<p>I = H - shift * S</p>
<p>where I is the same as the number of eigenvalues lambda for</p>
<p>H x = lambda S x</p>
<p>with lambda &lt; shift according to the Sylvester's law of inertia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shiftVec</td><td>Shift vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inertiaVec</td><td>Negative inertia count, the same size as shiftVec. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HMat</td><td>Hamiltonian matrix saved in distributed compressed sparse column format. See <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SMat</td><td>Overlap matrix saved in distributed compressed sparse column format. See <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note</b>: If SMat.size == 0, SMat is treated as an identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>The level of output information.<ul>
<li>= 0 : No output.</li>
<li>= 1 : Basic output (default)</li>
<li>= 2 : Detailed output. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58c0c46d2ab48c5fd722dcf1e1f4e76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c0c46d2ab48c5fd722dcf1e1f4e76a">&#9670;&nbsp;</a></span>CalculateNegativeInertiaReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PPEXSIData::CalculateNegativeInertiaReal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>shiftVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertiaVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the negative inertia (the number of eigenvalues below a shift) for real symmetric matrices. The factorization uses real arithemetic factorization routine. </p>
<p>This subroutine computes the negative inertia of the matrix</p>
<p>I = H - shift * S</p>
<p>where I is the same as the number of eigenvalues lambda for</p>
<p>H x = lambda S x</p>
<p>with lambda &lt; shift according to the Sylvester's law of inertia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shiftVec</td><td>Shift vectors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inertiaVec</td><td>Negative inertia count, the same size as shiftVec. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HMat</td><td>Hamiltonian matrix saved in distributed compressed sparse column format. See <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SMat</td><td>Overlap matrix saved in distributed compressed sparse column format. See <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note</b>: If SMat.size == 0, SMat is treated as an identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>The level of output information.<ul>
<li>= 0 : No output.</li>
<li>= 1 : Basic output (default)</li>
<li>= 2 : Detailed output. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad280cf7310af70b99ae90d08ed4b9eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad280cf7310af70b99ae90d08ed4b9eac">&#9670;&nbsp;</a></span>EnergyDensityRealMat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt;Real&gt;&amp; PEXSI::PPEXSIData::EnergyDensityRealMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Energy density matrix. <br  />
 </p>
<p>Can be used to estimate the total band energy via Tr[EDM*S] or the force, including the Hellman-Feynman force and the Pulay force. <br  />
 </p>

</div>
</div>
<a id="a136cd30bdca8b6cb68ac3bb6eb8bef40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136cd30bdca8b6cb68ac3bb6eb8bef40">&#9670;&nbsp;</a></span>FreeEnergyDensityRealMat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt;Real&gt;&amp; PEXSI::PPEXSIData::FreeEnergyDensityRealMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total Helmholtz free energy matrix (band energy part only). <br  />
 </p>
<p>The Helmholtz free energy is computed by Tr[rho_f*H].</p>
<p>For more information see Alavi, A., Kohanoff, J., Parrinello, M., &amp; Frenkel, D. (1994). Ab initio molecular dynamics with excited electrons. Physical review letters, 73(19), 25992602. <br  />
 </p>

</div>
</div>
<a id="a2a35368db40989fd4fc85919121aae13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a35368db40989fd4fc85919121aae13">&#9670;&nbsp;</a></span>RhoRealMat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt;Real&gt;&amp; PEXSI::PPEXSIData::RhoRealMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Density matrix. </p>
<p>Can be used to estimate the number of electrons by Tr[DM*S] or the band energy via Tr[DM*H] </p>

</div>
</div>
<a id="a8be01e7f1a5837becba789e9ca89ef2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be01e7f1a5837becba789e9ca89ef2c">&#9670;&nbsp;</a></span>SymbolicFactorizeComplexSymmetricMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PPEXSIData::SymbolicFactorizeComplexSymmetricMatrix </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>symmetricStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ColPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>numProcSymbFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolically factorize the loaded matrices for complex arithmetic factorization and selected inversion. </p>
<p>The symbolic information is saved internally at luComplexMat_ or sympackComplexMat_ and PMComplexMat_.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>Solver used: SuperLU_DIST or symPACK</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ColPerm</td><td>Permutation method used by the solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numProcSymbFact</td><td>Number of processors used for parallel symbolic factorization and PARMETIS/PT-SCOTCH. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>The level of output information.<ul>
<li>= 0 : No output.</li>
<li>= 1 : Basic output (default)</li>
<li>= 2 : Detailed output. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad06f6bad026eabc56862d9010c0c93bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06f6bad026eabc56862d9010c0c93bb">&#9670;&nbsp;</a></span>SymbolicFactorizeComplexUnsymmetricMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PPEXSIData::SymbolicFactorizeComplexUnsymmetricMatrix </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ColPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>RowPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>numProcSymbFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>Transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>AnzvalLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolically factorize the loaded matrices for complex arithmetic factorization and selected inversion. </p>
<p>The symbolic information is saved internally at luComplexMat_ and PMComplexUnsymMat_.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>Solver used: SuperLU_DIST</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ColPerm</td><td>Permutation method used for SuperLU_DIST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RowPerm</td><td>Row Permutation method used for SuperLU_DIST</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numProcSymbFact</td><td>Number of processors used for parallel symbolic factorization and PARMETIS/PT-SCOTCH. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Transpose</td><td>TODO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AnzvalLocal</td><td>non zero values for row permutation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>The level of output information.<ul>
<li>= 0 : No output.</li>
<li>= 1 : Basic output (default)</li>
<li>= 2 : Detailed output. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a5cb0eee28b63f26e886460643712d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5cb0eee28b63f26e886460643712d0">&#9670;&nbsp;</a></span>SymbolicFactorizeRealSymmetricMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PPEXSIData::SymbolicFactorizeRealSymmetricMatrix </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>symmetricStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ColPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>numProcSymbFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolically factorize the loaded matrices for real arithmetic factorization and selected inversion. </p>
<p>The symbolic information is saved internally at luRealMat_ or sympackRealMat_ and PMRealMat_.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>Solver used: SuperLU_DIST or symPACK</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ColPerm</td><td>Permutation method used by the solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numProcSymbFact</td><td>Number of processors used for parallel symbolic factorization and PARMETIS/PT-SCOTCH. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>The level of output information.<ul>
<li>= 0 : No output.</li>
<li>= 1 : Basic output (default)</li>
<li>= 2 : Detailed output. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb33d026b4dfead14fec7c33bedd735e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb33d026b4dfead14fec7c33bedd735e">&#9670;&nbsp;</a></span>SymbolicFactorizeRealUnsymmetricMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PPEXSIData::SymbolicFactorizeRealUnsymmetricMatrix </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ColPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>RowPerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>numProcSymbFact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>Transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>AnzvalLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolically factorize the loaded matrices for real arithmetic factorization and selected inversion. </p>
<p>The symbolic information is saved internally at luRealMat_ and PMRealMat_.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>Solver used: SuperLU_DIST</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ColPerm</td><td>Permutation method used for SuperLU_DIST </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RowPerm</td><td>Row Permutation method used for SuperLU_DIST</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numProcSymbFact</td><td>Number of processors used for parallel symbolic factorization and PARMETIS/PT-SCOTCH. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Transpose</td><td>TODO </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AnzvalLocal</td><td>non zero values for row permutation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>The level of output information.<ul>
<li>= 0 : No output.</li>
<li>= 1 : Basic output (default)</li>
<li>= 2 : Detailed output. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="ppexsi_8hpp_source.html">ppexsi.hpp</a></li>
<li>src/<a class="el" href="ppexsi_8cpp.html">ppexsi.cpp</a></li>
<li>src/<a class="el" href="ppexsi__real__old_8cpp.html">ppexsi_real_old.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 1 2022 20:34:01 for PEXSI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
