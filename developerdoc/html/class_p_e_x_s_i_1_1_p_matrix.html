<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PEXSI: PEXSI::PMatrix&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://math.berkeley.edu/~linlin/MathJax-2.6/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PEXSI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_p_e_x_s_i.html">PEXSI</a></li><li class="navelem"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_p_e_x_s_i_1_1_p_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PEXSI::PMatrix&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a> contains the main data structure and the computational routine for the parallel selected inversion. <br  />
  
 <a href="class_p_e_x_s_i_1_1_p_matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pselinv_8hpp_source.html">pselinv.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_1_1_super_node_buffer_type.html">SuperNodeBufferType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae8aeeb0a688a79a9deb8a5e5f1b9bcb2"><td class="memItemLeft" align="right" valign="top"><a id="ae8aeeb0a688a79a9deb8a5e5f1b9bcb2"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>SELINV_TAG_U_SIZE</b>, 
<b>SELINV_TAG_U_CONTENT</b>, 
<b>SELINV_TAG_L_SIZE</b>, 
<b>SELINV_TAG_L_CONTENT</b>, 
<br />
&#160;&#160;<b>SELINV_TAG_L_REDUCE</b>, 
<b>SELINV_TAG_D_SIZE</b>, 
<b>SELINV_TAG_D_CONTENT</b>, 
<b>SELINV_TAG_D_REDUCE</b>, 
<br />
&#160;&#160;<b>SELINV_TAG_L_SIZE_CD</b>, 
<b>SELINV_TAG_L_CONTENT_CD</b>, 
<b>SELINV_TAG_COUNT</b>
<br />
 }</td></tr>
<tr class="separator:ae8aeeb0a688a79a9deb8a5e5f1b9bcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0f4ea371234359306182c18a109298f4"><td class="memItemLeft" align="right" valign="top"><a id="a0f4ea371234359306182c18a109298f4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetTotalFlops</b> ()</td></tr>
<tr class="separator:a0f4ea371234359306182c18a109298f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3ed4bb4d2779d8f575cfda9e326b23"><td class="memItemLeft" align="right" valign="top"><a id="a8e3ed4bb4d2779d8f575cfda9e326b23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PMatrix</b> (const <a class="el" href="struct_p_e_x_s_i_1_1_grid_type.html">GridType</a> *g, const <a class="el" href="struct_p_e_x_s_i_1_1_super_node_type.html">SuperNodeType</a> *s, const <a class="el" href="struct_p_e_x_s_i_1_1_p_sel_inv_options.html">PEXSI::PSelInvOptions</a> *o, const <a class="el" href="struct_p_e_x_s_i_1_1_factorization_options.html">PEXSI::FactorizationOptions</a> *oFact)</td></tr>
<tr class="separator:a8e3ed4bb4d2779d8f575cfda9e326b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923e8af4ac1494f73093eb1ee94efbf7"><td class="memItemLeft" align="right" valign="top"><a id="a923e8af4ac1494f73093eb1ee94efbf7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate</b> ()</td></tr>
<tr class="separator:a923e8af4ac1494f73093eb1ee94efbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41f95dbfd90aada2b361a20eaf83c82"><td class="memItemLeft" align="right" valign="top"><a id="ab41f95dbfd90aada2b361a20eaf83c82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PMatrix</b> (const <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PMatrix</a> &amp;C)</td></tr>
<tr class="separator:ab41f95dbfd90aada2b361a20eaf83c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f7f02b8ae816939e6a27c884e0299"><td class="memItemLeft" align="right" valign="top"><a id="ad18f7f02b8ae816939e6a27c884e0299"></a>
<a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PMatrix</a> &amp;C)</td></tr>
<tr class="separator:ad18f7f02b8ae816939e6a27c884e0299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1d57a43131cd67ac736e0edeff0e15"><td class="memItemLeft" align="right" valign="top"><a id="a1d1d57a43131cd67ac736e0edeff0e15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Setup</b> (const <a class="el" href="struct_p_e_x_s_i_1_1_grid_type.html">GridType</a> *g, const <a class="el" href="struct_p_e_x_s_i_1_1_super_node_type.html">SuperNodeType</a> *s, const <a class="el" href="struct_p_e_x_s_i_1_1_p_sel_inv_options.html">PEXSI::PSelInvOptions</a> *o, const <a class="el" href="struct_p_e_x_s_i_1_1_factorization_options.html">PEXSI::FactorizationOptions</a> *oFact)</td></tr>
<tr class="separator:a1d1d57a43131cd67ac736e0edeff0e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a0cc1f8ff19dfec4df00527fe259c1"><td class="memItemLeft" align="right" valign="top"><a id="a44a0cc1f8ff19dfec4df00527fe259c1"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_p_sel_inv_options.html">PSelInvOptions</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Options</b> () const</td></tr>
<tr class="separator:a44a0cc1f8ff19dfec4df00527fe259c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4150836e2f89176f7844692794c9213c"><td class="memItemLeft" align="right" valign="top"><a id="a4150836e2f89176f7844692794c9213c"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><b>NumCol</b> () const</td></tr>
<tr class="separator:a4150836e2f89176f7844692794c9213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf349573e6364da21f59db2ca9e6e609"><td class="memItemLeft" align="right" valign="top"><a id="abf349573e6364da21f59db2ca9e6e609"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><b>NumSuper</b> () const</td></tr>
<tr class="separator:abf349573e6364da21f59db2ca9e6e609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756554d397d314acdccb13d723d57eba"><td class="memItemLeft" align="right" valign="top"><a id="a756554d397d314acdccb13d723d57eba"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a756554d397d314acdccb13d723d57eba">NumLocalBlockCol</a> () const</td></tr>
<tr class="memdesc:a756554d397d314acdccb13d723d57eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">NumLocalBlockCol returns the total number of block columns. <br /></td></tr>
<tr class="separator:a756554d397d314acdccb13d723d57eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6657a74cd241455688d75388a67aa4d9"><td class="memItemLeft" align="right" valign="top"><a id="a6657a74cd241455688d75388a67aa4d9"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a6657a74cd241455688d75388a67aa4d9">NumLocalBlockRow</a> () const</td></tr>
<tr class="memdesc:a6657a74cd241455688d75388a67aa4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">NumLocalBlockRow returns the total number of block rows. <br /></td></tr>
<tr class="separator:a6657a74cd241455688d75388a67aa4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8252568cb3df3de5d23c96bc1efeb16a"><td class="memItemLeft" align="right" valign="top"><a id="a8252568cb3df3de5d23c96bc1efeb16a"></a>
std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ColBlockIdx</b> ()</td></tr>
<tr class="separator:a8252568cb3df3de5d23c96bc1efeb16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9455e15b7218f8a13d55f56d7aee1c51"><td class="memItemLeft" align="right" valign="top"><a id="a9455e15b7218f8a13d55f56d7aee1c51"></a>
std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RowBlockIdx</b> ()</td></tr>
<tr class="separator:a9455e15b7218f8a13d55f56d7aee1c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab42a727a34e92e575a6aa6d46685a60"><td class="memItemLeft" align="right" valign="top"><a id="aab42a727a34e92e575a6aa6d46685a60"></a>
std::vector&lt; Int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ColBlockIdx</b> (Int jLocal)</td></tr>
<tr class="separator:aab42a727a34e92e575a6aa6d46685a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b0fb1c88968acfe25f1158e79f4576"><td class="memItemLeft" align="right" valign="top"><a id="a39b0fb1c88968acfe25f1158e79f4576"></a>
std::vector&lt; Int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RowBlockIdx</b> (Int iLocal)</td></tr>
<tr class="separator:a39b0fb1c88968acfe25f1158e79f4576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ebe91efc4ec5f6ded82c178709326d"><td class="memItemLeft" align="right" valign="top"><a id="a81ebe91efc4ec5f6ded82c178709326d"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a81ebe91efc4ec5f6ded82c178709326d">NumBlockL</a> (Int jLocal) const</td></tr>
<tr class="memdesc:a81ebe91efc4ec5f6ded82c178709326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">NumBlockL returns the number of nonzero L blocks for the local block column jLocal. <br /></td></tr>
<tr class="separator:a81ebe91efc4ec5f6ded82c178709326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d17a5569a7ba5266f337895a0bf6b6f"><td class="memItemLeft" align="right" valign="top"><a id="a3d17a5569a7ba5266f337895a0bf6b6f"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a3d17a5569a7ba5266f337895a0bf6b6f">NumBlockU</a> (Int iLocal) const</td></tr>
<tr class="memdesc:a3d17a5569a7ba5266f337895a0bf6b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">NumBlockU returns the number of nonzero U blocks for the local block row iLocal. <br /></td></tr>
<tr class="separator:a3d17a5569a7ba5266f337895a0bf6b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af250e3e3bc8a0bd110fa86d7f22652dd"><td class="memItemLeft" align="right" valign="top"><a id="af250e3e3bc8a0bd110fa86d7f22652dd"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_grid_type.html">GridType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#af250e3e3bc8a0bd110fa86d7f22652dd">Grid</a> () const</td></tr>
<tr class="memdesc:af250e3e3bc8a0bd110fa86d7f22652dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid returns the <a class="el" href="struct_p_e_x_s_i_1_1_grid_type.html" title="GridType is the PSelInv way of defining the grid.">GridType</a> structure of the current <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a>. <br /></td></tr>
<tr class="separator:af250e3e3bc8a0bd110fa86d7f22652dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78928065cd92afa6cc64de52427218c5"><td class="memItemLeft" align="right" valign="top"><a id="a78928065cd92afa6cc64de52427218c5"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_super_node_type.html">SuperNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a78928065cd92afa6cc64de52427218c5">SuperNode</a> () const</td></tr>
<tr class="memdesc:a78928065cd92afa6cc64de52427218c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SuperNode returns the supernodal partition of the current <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a>. <br /></td></tr>
<tr class="separator:a78928065cd92afa6cc64de52427218c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae903aab36190757de211c06a41a0805d"><td class="memItemLeft" align="right" valign="top"><a id="ae903aab36190757de211c06a41a0805d"></a>
std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#ae903aab36190757de211c06a41a0805d">L</a> (Int jLocal)</td></tr>
<tr class="memdesc:ae903aab36190757de211c06a41a0805d"><td class="mdescLeft">&#160;</td><td class="mdescRight">L returns the vector of nonzero L blocks for the local block column jLocal. <br /></td></tr>
<tr class="separator:ae903aab36190757de211c06a41a0805d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67610d32ab1ad28a4d66d625d52933c2"><td class="memItemLeft" align="right" valign="top"><a id="a67610d32ab1ad28a4d66d625d52933c2"></a>
std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a67610d32ab1ad28a4d66d625d52933c2">U</a> (Int iLocal)</td></tr>
<tr class="memdesc:a67610d32ab1ad28a4d66d625d52933c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">U returns the vector of nonzero U blocks for the local block row iLocal. <br /></td></tr>
<tr class="separator:a67610d32ab1ad28a4d66d625d52933c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4730471c1b21319767b10a019c0565"><td class="memItemLeft" align="right" valign="top"><a id="a3a4730471c1b21319767b10a019c0565"></a>
std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a3a4730471c1b21319767b10a019c0565">WorkingSet</a> ()</td></tr>
<tr class="memdesc:a3a4730471c1b21319767b10a019c0565"><td class="mdescLeft">&#160;</td><td class="mdescRight">WorkingSet returns the ordered list of supernodes which could be done in parallel. <br /></td></tr>
<tr class="separator:a3a4730471c1b21319767b10a019c0565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845a3ac3724629ee00b445a493e18343"><td class="memItemLeft" align="right" valign="top"><a id="a845a3ac3724629ee00b445a493e18343"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a845a3ac3724629ee00b445a493e18343">CountSendToRight</a> (Int ksup)</td></tr>
<tr class="memdesc:a845a3ac3724629ee00b445a493e18343"><td class="mdescLeft">&#160;</td><td class="mdescRight">CountSendToRight returns the number of processors to the right of current processor with which it has to communicate. <br /></td></tr>
<tr class="separator:a845a3ac3724629ee00b445a493e18343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4330e528142a67d69217b26586775d"><td class="memItemLeft" align="right" valign="top"><a id="aab4330e528142a67d69217b26586775d"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#aab4330e528142a67d69217b26586775d">CountSendToBelow</a> (Int ksup)</td></tr>
<tr class="memdesc:aab4330e528142a67d69217b26586775d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CountSendToBelow returns the number of processors below current processor with which it has to communicate. <br /></td></tr>
<tr class="separator:aab4330e528142a67d69217b26586775d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29996413cccd4e764ef1671f762255b6"><td class="memItemLeft" align="right" valign="top"><a id="a29996413cccd4e764ef1671f762255b6"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a29996413cccd4e764ef1671f762255b6">CountRecvFromBelow</a> (Int ksup)</td></tr>
<tr class="memdesc:a29996413cccd4e764ef1671f762255b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CountRecvFromBelow returns the number of processors below the current processor from which it receives data. <br /></td></tr>
<tr class="separator:a29996413cccd4e764ef1671f762255b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da87bfb5b7a691452559cf276e8823f"><td class="memItemLeft" align="right" valign="top"><a id="a2da87bfb5b7a691452559cf276e8823f"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a2da87bfb5b7a691452559cf276e8823f">CountSendToCrossDiagonal</a> (Int ksup)</td></tr>
<tr class="memdesc:a2da87bfb5b7a691452559cf276e8823f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CountSendToCrossDiagonal returns the number of cross diagonal processors with which current processor has to communicate. <br /></td></tr>
<tr class="separator:a2da87bfb5b7a691452559cf276e8823f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99a1bcf885931784f56be579ce4458e"><td class="memItemLeft" align="right" valign="top"><a id="ab99a1bcf885931784f56be579ce4458e"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#ab99a1bcf885931784f56be579ce4458e">CountRecvFromCrossDiagonal</a> (Int ksup)</td></tr>
<tr class="memdesc:ab99a1bcf885931784f56be579ce4458e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CountRecvFromCrossDiagonal returns the number of cross diagonal processors with which current processor has to communicate. <br /></td></tr>
<tr class="separator:ab99a1bcf885931784f56be579ce4458e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8938202572577a2db1db8f3835e59a1b"><td class="memItemLeft" align="right" valign="top"><a id="a8938202572577a2db1db8f3835e59a1b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a8938202572577a2db1db8f3835e59a1b">GetEtree</a> (std::vector&lt; Int &gt; &amp;etree_supno)</td></tr>
<tr class="memdesc:a8938202572577a2db1db8f3835e59a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetEtree computes the supernodal elimination tree to be used later in the pipelined selected inversion stage. <br /></td></tr>
<tr class="separator:a8938202572577a2db1db8f3835e59a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab522c5b09ef23435a1292a1be1074f"><td class="memItemLeft" align="right" valign="top"><a id="a9ab522c5b09ef23435a1292a1be1074f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a9ab522c5b09ef23435a1292a1be1074f">ConstructCommunicationPattern</a> ()</td></tr>
<tr class="memdesc:a9ab522c5b09ef23435a1292a1be1074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConstructCommunicationPattern constructs the communication pattern to be used later in the selected inversion stage. The supernodal elimination tree is used to add an additional level of parallelism between supernodes. <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#ab3fb44f9da5a32e6baae98fa8519045d">ConstructCommunicationPattern_P2p</a> is called by default. <br /></td></tr>
<tr class="separator:a9ab522c5b09ef23435a1292a1be1074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fb44f9da5a32e6baae98fa8519045d"><td class="memItemLeft" align="right" valign="top"><a id="ab3fb44f9da5a32e6baae98fa8519045d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#ab3fb44f9da5a32e6baae98fa8519045d">ConstructCommunicationPattern_P2p</a> ()</td></tr>
<tr class="memdesc:ab3fb44f9da5a32e6baae98fa8519045d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConstructCommunicationPattern_P2p constructs the communication pattern to be used later in the selected inversion stage. The supernodal elimination tree is used to add an additional level of parallelism between supernodes. <br /></td></tr>
<tr class="separator:ab3fb44f9da5a32e6baae98fa8519045d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5881204ac3a6b2807b88657727635208"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a5881204ac3a6b2807b88657727635208">PreSelInv</a> ()</td></tr>
<tr class="memdesc:a5881204ac3a6b2807b88657727635208"><td class="mdescLeft">&#160;</td><td class="mdescRight">PreSelInv prepares the structure in L_ and U_ so that SelInv only involves matrix-matrix multiplication.  <a href="class_p_e_x_s_i_1_1_p_matrix.html#a5881204ac3a6b2807b88657727635208">More...</a><br /></td></tr>
<tr class="separator:a5881204ac3a6b2807b88657727635208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b608a2b05cb1ef1c20e0767bc5f81db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a6b608a2b05cb1ef1c20e0767bc5f81db">SelInv</a> ()</td></tr>
<tr class="memdesc:a6b608a2b05cb1ef1c20e0767bc5f81db"><td class="mdescLeft">&#160;</td><td class="mdescRight">SelInv is the main function for the selected inversion.  <a href="class_p_e_x_s_i_1_1_p_matrix.html#a6b608a2b05cb1ef1c20e0767bc5f81db">More...</a><br /></td></tr>
<tr class="separator:a6b608a2b05cb1ef1c20e0767bc5f81db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8abb5c3505ddac3a11b4a1a8690621e"><td class="memItemLeft" align="right" valign="top"><a id="af8abb5c3505ddac3a11b4a1a8690621e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#af8abb5c3505ddac3a11b4a1a8690621e">SelInv_P2p</a> ()</td></tr>
<tr class="memdesc:af8abb5c3505ddac3a11b4a1a8690621e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-point version of the selected inversion. <br /></td></tr>
<tr class="separator:af8abb5c3505ddac3a11b4a1a8690621e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3df0961e1a11d9a5f53f4950f996f84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#ad3df0961e1a11d9a5f53f4950f996f84">GetDiagonal</a> (<a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">NumVec</a>&lt; T &gt; &amp;diag)</td></tr>
<tr class="memdesc:ad3df0961e1a11d9a5f53f4950f996f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetDiagonal extracts the diagonal elements of the <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a>.  <a href="class_p_e_x_s_i_1_1_p_matrix.html#ad3df0961e1a11d9a5f53f4950f996f84">More...</a><br /></td></tr>
<tr class="separator:ad3df0961e1a11d9a5f53f4950f996f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb8bf1bfb962da5393a7d6a866f7b8f"><td class="memItemLeft" align="right" valign="top"><a id="a0bb8bf1bfb962da5393a7d6a866f7b8f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetColumn</b> (Int colIdx, <a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">NumVec</a>&lt; T &gt; &amp;col)</td></tr>
<tr class="separator:a0bb8bf1bfb962da5393a7d6a866f7b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d190f3a20b58173cff10aa95a89bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a22d190f3a20b58173cff10aa95a89bd1">PMatrixToDistSparseMatrix</a> (<a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a22d190f3a20b58173cff10aa95a89bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMatrixToDistSparseMatrix converts the <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a> into a distributed compressed sparse column matrix format. The <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a> follows the natural order.  <a href="class_p_e_x_s_i_1_1_p_matrix.html#a22d190f3a20b58173cff10aa95a89bd1">More...</a><br /></td></tr>
<tr class="separator:a22d190f3a20b58173cff10aa95a89bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869d3f7ef697dc77091ce224882b1ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a869d3f7ef697dc77091ce224882b1ab0">PMatrixToDistSparseMatrix_OLD</a> (const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;A, <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;B)</td></tr>
<tr class="memdesc:a869d3f7ef697dc77091ce224882b1ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMatrixToDistSparseMatrix_OLD converts the <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a> into a distributed compressed sparse column matrix format B, which has the same sparsity pattern as the <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a> A.  <a href="class_p_e_x_s_i_1_1_p_matrix.html#a869d3f7ef697dc77091ce224882b1ab0">More...</a><br /></td></tr>
<tr class="separator:a869d3f7ef697dc77091ce224882b1ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5264f2c2fb65d66882609dc4e29192e9"><td class="memTemplParams" colspan="2">template&lt;typename T1  = T&gt; </td></tr>
<tr class="memitem:a5264f2c2fb65d66882609dc4e29192e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a5264f2c2fb65d66882609dc4e29192e9">PMatrixToDistSparseMatrix</a> (const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T1 &gt; &amp;A, <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;B)</td></tr>
<tr class="memdesc:a5264f2c2fb65d66882609dc4e29192e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">PMatrixToDistSparseMatrix converts the <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a> into a distributed compressed sparse column matrix format B, which has the same sparsity pattern as the <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a> A.  <a href="class_p_e_x_s_i_1_1_p_matrix.html#a5264f2c2fb65d66882609dc4e29192e9">More...</a><br /></td></tr>
<tr class="separator:a5264f2c2fb65d66882609dc4e29192e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325a54903c713fad23177bb39199aee8"><td class="memItemLeft" align="right" valign="top"><a id="a325a54903c713fad23177bb39199aee8"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a325a54903c713fad23177bb39199aee8">NnzLocal</a> ()</td></tr>
<tr class="memdesc:a325a54903c713fad23177bb39199aee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">NnzLocal computes the number of nonzero elements (L and U) saved locally. <br /></td></tr>
<tr class="separator:a325a54903c713fad23177bb39199aee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8cf1a1182fd2e6303bf9c6fe044fd9"><td class="memItemLeft" align="right" valign="top"><a id="a0b8cf1a1182fd2e6303bf9c6fe044fd9"></a>
LongInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a0b8cf1a1182fd2e6303bf9c6fe044fd9">Nnz</a> ()</td></tr>
<tr class="memdesc:a0b8cf1a1182fd2e6303bf9c6fe044fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nnz computes the total number of nonzero elements in the <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a>. <br /></td></tr>
<tr class="separator:a0b8cf1a1182fd2e6303bf9c6fe044fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4415950d901eeb32f5ad3a9c96140a2"><td class="memItemLeft" align="right" valign="top"><a id="ab4415950d901eeb32f5ad3a9c96140a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#ab4415950d901eeb32f5ad3a9c96140a2">GetNegativeInertia</a> (Real &amp;inertia)</td></tr>
<tr class="memdesc:ab4415950d901eeb32f5ad3a9c96140a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetNegativeInertia computes the negative inertia of a <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a>. This can be used to estimate e.g. the number of eigenvalues of a matrix below a certain threshold. <br /></td></tr>
<tr class="separator:ab4415950d901eeb32f5ad3a9c96140a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72584ed5347b1d78d8c7e6ca9c46f47c"><td class="memItemLeft" align="right" valign="top"><a id="a72584ed5347b1d78d8c7e6ca9c46f47c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DumpLU</b> ()</td></tr>
<tr class="separator:a72584ed5347b1d78d8c7e6ca9c46f47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0edac592ce0c24d10de83da15bca92f"><td class="memItemLeft" align="right" valign="top"><a id="ac0edac592ce0c24d10de83da15bca92f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyLU</b> (const <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PMatrix</a> &amp;C)</td></tr>
<tr class="separator:ac0edac592ce0c24d10de83da15bca92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247165ea93b4d2fc20adcd528f9f570f"><td class="memItemLeft" align="right" valign="top"><a id="a247165ea93b4d2fc20adcd528f9f570f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>IdxToTag</b> (Int lidx, Int tag)</td></tr>
<tr class="separator:a247165ea93b4d2fc20adcd528f9f570f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fb35b6c4d424c684291323b2b15bf5"><td class="memItemLeft" align="right" valign="top"><a id="a39fb35b6c4d424c684291323b2b15bf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetNegativeInertia</b> (Real &amp;inertia)</td></tr>
<tr class="separator:a39fb35b6c4d424c684291323b2b15bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde241e0b74986734bd30a527e76ef7e"><td class="memItemLeft" align="right" valign="top"><a id="adde241e0b74986734bd30a527e76ef7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetNegativeInertia</b> (Real &amp;inertia)</td></tr>
<tr class="separator:adde241e0b74986734bd30a527e76ef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2d3df622b1b9e3906331ddcea24efaf1"><td class="memItemLeft" align="right" valign="top"><a id="a2d3df622b1b9e3906331ddcea24efaf1"></a>
static <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PMatrix</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a2d3df622b1b9e3906331ddcea24efaf1">Create</a> (const <a class="el" href="struct_p_e_x_s_i_1_1_grid_type.html">GridType</a> *pGridType, const <a class="el" href="struct_p_e_x_s_i_1_1_super_node_type.html">SuperNodeType</a> *pSuper, const <a class="el" href="struct_p_e_x_s_i_1_1_p_sel_inv_options.html">PSelInvOptions</a> *pSelInvOpt, const <a class="el" href="struct_p_e_x_s_i_1_1_factorization_options.html">FactorizationOptions</a> *pFactOpt)</td></tr>
<tr class="memdesc:a2d3df622b1b9e3906331ddcea24efaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create is a factory method which returns a pointer either to a new <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a> or to a new <a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html" title="PMatrixUnsym contains the main data structure and the computational routine for the parallel selected...">PMatrixUnsym</a> depending on the pLuOpt parameter. <br /></td></tr>
<tr class="separator:a2d3df622b1b9e3906331ddcea24efaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5474e89299791d7f40041ff04c20250f"><td class="memItemLeft" align="right" valign="top"><a id="a5474e89299791d7f40041ff04c20250f"></a>
static <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PMatrix</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>Create</b> (const <a class="el" href="struct_p_e_x_s_i_1_1_factorization_options.html">FactorizationOptions</a> *pFactOpt)</td></tr>
<tr class="separator:a5474e89299791d7f40041ff04c20250f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aadddab1fdd3a681c133d1c0fef921400"><td class="memItemLeft" align="right" valign="top"><a id="aadddab1fdd3a681c133d1c0fef921400"></a>
std::vector&lt; std::vector&lt; Int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ColBlockIdx_</b></td></tr>
<tr class="separator:aadddab1fdd3a681c133d1c0fef921400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d6fb6333a8373d37f8c969d21d70d9"><td class="memItemLeft" align="right" valign="top"><a id="a72d6fb6333a8373d37f8c969d21d70d9"></a>
std::vector&lt; std::vector&lt; Int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RowBlockIdx_</b></td></tr>
<tr class="separator:a72d6fb6333a8373d37f8c969d21d70d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0f02beb3fb29d2b441fe27f812794bd0"><td class="memItemLeft" align="right" valign="top"><a id="a0f02beb3fb29d2b441fe27f812794bd0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>PMatrixToDistSparseMatrix_</b> (const <a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">NumVec</a>&lt; Int &gt; &amp;AcolptrLocal, const <a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">NumVec</a>&lt; Int &gt; &amp;ArowindLocal, const Int Asize, const LongInt Annz, const Int AnnzLocal, <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;B)</td></tr>
<tr class="separator:a0f02beb3fb29d2b441fe27f812794bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3964a5ce76cc6eca723d4990444fb9"><td class="memItemLeft" align="right" valign="top"><a id="aec3964a5ce76cc6eca723d4990444fb9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#aec3964a5ce76cc6eca723d4990444fb9">SelInvIntra_P2p</a> (Int lidx, Int &amp;rank)</td></tr>
<tr class="memdesc:aec3964a5ce76cc6eca723d4990444fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SelInvIntra_P2p. <br /></td></tr>
<tr class="separator:aec3964a5ce76cc6eca723d4990444fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736946e3b878fd5318d882bbc8d218ff"><td class="memItemLeft" align="right" valign="top"><a id="a736946e3b878fd5318d882bbc8d218ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a736946e3b878fd5318d882bbc8d218ff">SelInv_lookup_indexes</a> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_1_1_super_node_buffer_type.html">SuperNodeBufferType</a> &amp;snode, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;LcolRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;UrowRecv, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;AinvBuf, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;UBuf)</td></tr>
<tr class="memdesc:a736946e3b878fd5318d882bbc8d218ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">SelInv_lookup_indexes. <br /></td></tr>
<tr class="separator:a736946e3b878fd5318d882bbc8d218ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137daa7dabda48959c344dc722d938f3"><td class="memItemLeft" align="right" valign="top"><a id="a137daa7dabda48959c344dc722d938f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SelInv_lookup_indexes_seq</b> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_1_1_super_node_buffer_type.html">SuperNodeBufferType</a> &amp;snode, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;LcolRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;UrowRecv, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;AinvBuf, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;UBuf)</td></tr>
<tr class="separator:a137daa7dabda48959c344dc722d938f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0f3b44c2871b0e0fa8c51801dbde83"><td class="memItemLeft" align="right" valign="top"><a id="aab0f3b44c2871b0e0fa8c51801dbde83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#aab0f3b44c2871b0e0fa8c51801dbde83">GetWorkSet</a> (std::vector&lt; Int &gt; &amp;snodeEtree, std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;WSet)</td></tr>
<tr class="memdesc:aab0f3b44c2871b0e0fa8c51801dbde83"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetWorkSet. <br /></td></tr>
<tr class="separator:aab0f3b44c2871b0e0fa8c51801dbde83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b1a1febda3c34fbb1eafc1bcb4fd51"><td class="memItemLeft" align="right" valign="top"><a id="af0b1a1febda3c34fbb1eafc1bcb4fd51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#af0b1a1febda3c34fbb1eafc1bcb4fd51">UnpackData</a> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_1_1_super_node_buffer_type.html">SuperNodeBufferType</a> &amp;snode, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;LcolRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;UrowRecv)</td></tr>
<tr class="memdesc:af0b1a1febda3c34fbb1eafc1bcb4fd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnpackData. <br /></td></tr>
<tr class="separator:af0b1a1febda3c34fbb1eafc1bcb4fd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3026c708a931b10798c69fa6dea1470"><td class="memItemLeft" align="right" valign="top"><a id="ac3026c708a931b10798c69fa6dea1470"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#ac3026c708a931b10798c69fa6dea1470">ComputeDiagUpdate</a> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_1_1_super_node_buffer_type.html">SuperNodeBufferType</a> &amp;snode)</td></tr>
<tr class="memdesc:ac3026c708a931b10798c69fa6dea1470"><td class="mdescLeft">&#160;</td><td class="mdescRight">ComputeDiagUpdate. <br /></td></tr>
<tr class="separator:ac3026c708a931b10798c69fa6dea1470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51690819932cd78268f3eff8296c0234"><td class="memItemLeft" align="right" valign="top"><a id="a51690819932cd78268f3eff8296c0234"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a51690819932cd78268f3eff8296c0234">SendRecvCD_UpdateU</a> (std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_1_1_super_node_buffer_type.html">SuperNodeBufferType</a> &gt; &amp;arrSuperNodes, Int stepSuper)</td></tr>
<tr class="memdesc:a51690819932cd78268f3eff8296c0234"><td class="mdescLeft">&#160;</td><td class="mdescRight">SendRecvCD_UpdateU. <br /></td></tr>
<tr class="separator:a51690819932cd78268f3eff8296c0234"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a767851c5eff093bfaf7546ba1b4f68d0"><td class="memItemLeft" align="right" valign="top"><a id="a767851c5eff093bfaf7546ba1b4f68d0"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_grid_type.html">GridType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>grid_</b></td></tr>
<tr class="separator:a767851c5eff093bfaf7546ba1b4f68d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f15e145337bca69e6e8ba3b4aac5be5"><td class="memItemLeft" align="right" valign="top"><a id="a5f15e145337bca69e6e8ba3b4aac5be5"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_super_node_type.html">SuperNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>super_</b></td></tr>
<tr class="separator:a5f15e145337bca69e6e8ba3b4aac5be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93378cb6fc779b3a8f175f3dda08a184"><td class="memItemLeft" align="right" valign="top"><a id="a93378cb6fc779b3a8f175f3dda08a184"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_p_sel_inv_options.html">PSelInvOptions</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>options_</b></td></tr>
<tr class="separator:a93378cb6fc779b3a8f175f3dda08a184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5200715b8a9333083a4c882f0235192"><td class="memItemLeft" align="right" valign="top"><a id="af5200715b8a9333083a4c882f0235192"></a>
const <a class="el" href="struct_p_e_x_s_i_1_1_factorization_options.html">FactorizationOptions</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>optionsFact_</b></td></tr>
<tr class="separator:af5200715b8a9333083a4c882f0235192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81978d75cc4824f6552e8f35ab872420"><td class="memItemLeft" align="right" valign="top"><a id="a81978d75cc4824f6552e8f35ab872420"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><b>limIndex_</b></td></tr>
<tr class="separator:a81978d75cc4824f6552e8f35ab872420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae002c998466976bb63d1e9b5b990583e"><td class="memItemLeft" align="right" valign="top"><a id="ae002c998466976bb63d1e9b5b990583e"></a>
Int&#160;</td><td class="memItemRight" valign="bottom"><b>maxTag_</b></td></tr>
<tr class="separator:ae002c998466976bb63d1e9b5b990583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde3f4d28f56bb00f5de5a584302ad58"><td class="memItemLeft" align="right" valign="top"><a id="adde3f4d28f56bb00f5de5a584302ad58"></a>
std::vector&lt; std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>L_</b></td></tr>
<tr class="separator:adde3f4d28f56bb00f5de5a584302ad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522389f63acbdfc59a24d893fb2bd806"><td class="memItemLeft" align="right" valign="top"><a id="a522389f63acbdfc59a24d893fb2bd806"></a>
std::vector&lt; std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>U_</b></td></tr>
<tr class="separator:a522389f63acbdfc59a24d893fb2bd806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8d95b7a503b4d731e373bb36036a8a"><td class="memItemLeft" align="right" valign="top"><a id="abb8d95b7a503b4d731e373bb36036a8a"></a>
std::vector&lt; std::vector&lt; Int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>workingSet_</b></td></tr>
<tr class="separator:abb8d95b7a503b4d731e373bb36036a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e24067a4d13c24652ad2a5bd87d4f72"><td class="memItemLeft" align="right" valign="top"><a id="a5e24067a4d13c24652ad2a5bd87d4f72"></a>
<a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">BolNumMat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSendToBelow_</b></td></tr>
<tr class="separator:a5e24067a4d13c24652ad2a5bd87d4f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eebca81788c37637c870f6c05eb804"><td class="memItemLeft" align="right" valign="top"><a id="ad9eebca81788c37637c870f6c05eb804"></a>
<a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">BolNumMat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSendToRight_</b></td></tr>
<tr class="separator:ad9eebca81788c37637c870f6c05eb804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1126a34ff8b0402d8343f01a66fb3801"><td class="memItemLeft" align="right" valign="top"><a id="a1126a34ff8b0402d8343f01a66fb3801"></a>
<a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">BolNumVec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSendToDiagonal_</b></td></tr>
<tr class="separator:a1126a34ff8b0402d8343f01a66fb3801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b30d0b7b0915c5cb026a8750d928c3"><td class="memItemLeft" align="right" valign="top"><a id="a40b30d0b7b0915c5cb026a8750d928c3"></a>
<a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">BolNumMat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isSendToCrossDiagonal_</b></td></tr>
<tr class="separator:a40b30d0b7b0915c5cb026a8750d928c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dafefe465780704cf953f111afdfd9d"><td class="memItemLeft" align="right" valign="top"><a id="a1dafefe465780704cf953f111afdfd9d"></a>
<a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">BolNumMat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isRecvFromBelow_</b></td></tr>
<tr class="separator:a1dafefe465780704cf953f111afdfd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a11733be8be54998380f4bd71ecc1a"><td class="memItemLeft" align="right" valign="top"><a id="ac3a11733be8be54998380f4bd71ecc1a"></a>
<a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">BolNumVec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isRecvFromAbove_</b></td></tr>
<tr class="separator:ac3a11733be8be54998380f4bd71ecc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7d41a27e74fbf7cc241bc0a86ea35"><td class="memItemLeft" align="right" valign="top"><a id="ab0c7d41a27e74fbf7cc241bc0a86ea35"></a>
<a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">BolNumVec</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isRecvFromLeft_</b></td></tr>
<tr class="separator:ab0c7d41a27e74fbf7cc241bc0a86ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d3b614aee5616efec75942123f77ef"><td class="memItemLeft" align="right" valign="top"><a id="ad6d3b614aee5616efec75942123f77ef"></a>
<a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">BolNumMat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>isRecvFromCrossDiagonal_</b></td></tr>
<tr class="separator:ad6d3b614aee5616efec75942123f77ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221d6aeb19238fbab2ec475ad30f2e11"><td class="memItemLeft" align="right" valign="top"><a id="a221d6aeb19238fbab2ec475ad30f2e11"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_reduce__v2.html">TreeReduce_v2</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>redDTree2_</b></td></tr>
<tr class="separator:a221d6aeb19238fbab2ec475ad30f2e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1104c4c08dbc8f36f029a6da5508a682"><td class="memItemLeft" align="right" valign="top"><a id="a1104c4c08dbc8f36f029a6da5508a682"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_bcast__v2.html">TreeBcast_v2</a>&lt; char &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bcastLDataTree_</b></td></tr>
<tr class="separator:a1104c4c08dbc8f36f029a6da5508a682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1aff3d3170e7a5727b03b99e11dbd1"><td class="memItemLeft" align="right" valign="top"><a id="aff1aff3d3170e7a5727b03b99e11dbd1"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_reduce__v2.html">TreeReduce_v2</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>redLTree2_</b></td></tr>
<tr class="separator:aff1aff3d3170e7a5727b03b99e11dbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefead6aa5acbbb1ca77e3746cfc130c1"><td class="memItemLeft" align="right" valign="top"><a id="aefead6aa5acbbb1ca77e3746cfc130c1"></a>
std::vector&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_bcast.html">TreeBcast</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fwdToBelowTree_</b></td></tr>
<tr class="separator:aefead6aa5acbbb1ca77e3746cfc130c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6779f32e14943da6b4102b7a63011fcb"><td class="memItemLeft" align="right" valign="top"><a id="a6779f32e14943da6b4102b7a63011fcb"></a>
std::vector&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_bcast.html">TreeBcast</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fwdToRightTree_</b></td></tr>
<tr class="separator:a6779f32e14943da6b4102b7a63011fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa933dee9ce051e33b25376f5554263d7"><td class="memItemLeft" align="right" valign="top"><a id="aa933dee9ce051e33b25376f5554263d7"></a>
std::vector&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_reduce.html">TreeReduce</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>redToLeftTree_</b></td></tr>
<tr class="separator:aa933dee9ce051e33b25376f5554263d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc2f0c2631e39490162f6e1af78fe6b"><td class="memItemLeft" align="right" valign="top"><a id="a2bc2f0c2631e39490162f6e1af78fe6b"></a>
std::vector&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_reduce.html">TreeReduce</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>redToAboveTree_</b></td></tr>
<tr class="separator:a2bc2f0c2631e39490162f6e1af78fe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe739d29c46be7c8e7fd7aef4263770"><td class="memItemLeft" align="right" valign="top"><a id="aefe739d29c46be7c8e7fd7aef4263770"></a>
std::vector&lt; Int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>snodeEtree_</b></td></tr>
<tr class="separator:aefe739d29c46be7c8e7fd7aef4263770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce2951d33e545ab3839adc0c5085d1b"><td class="memItemLeft" align="right" valign="top"><a id="a9ce2951d33e545ab3839adc0c5085d1b"></a>
std::vector&lt; Int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>snodeTreeOffset_</b></td></tr>
<tr class="separator:a9ce2951d33e545ab3839adc0c5085d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f3c89b21e5a71a43f8c8d000931fc9"><td class="memItemLeft" align="right" valign="top"><a id="a69f3c89b21e5a71a43f8c8d000931fc9"></a>
std::vector&lt; std::map&lt; Int, Int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>snodeBlkidxToTree_</b></td></tr>
<tr class="separator:a69f3c89b21e5a71a43f8c8d000931fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdb4ba971c519f921c0d10e8bbad897"><td class="memItemLeft" align="right" valign="top"><a id="a7bdb4ba971c519f921c0d10e8bbad897"></a>
std::vector&lt; std::vector&lt; Int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>snodeTreeToBlkidx_</b></td></tr>
<tr class="separator:a7bdb4ba971c519f921c0d10e8bbad897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab407f8133b46863d8b05fbfcaae4edfa"><td class="memItemLeft" align="right" valign="top"><a id="ab407f8133b46863d8b05fbfcaae4edfa"></a>
std::list&lt; Int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>syncPoints_</b></td></tr>
<tr class="separator:ab407f8133b46863d8b05fbfcaae4edfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade17b05ce5a08d6e947c3dd1346c5952"><td class="memItemLeft" align="right" valign="top"><a id="ade17b05ce5a08d6e947c3dd1346c5952"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>localFlops_</b></td></tr>
<tr class="separator:ade17b05ce5a08d6e947c3dd1346c5952"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class PEXSI::PMatrix&lt; T &gt;</h3>

<p><a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a> contains the main data structure and the computational routine for the parallel selected inversion. <br  />
 </p>
<p><b>NOTE</b> The following is a bit obsolete.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Procedure for Selected Inversion</h2>
<p>After factorizing a <a class="el" href="class_p_e_x_s_i_1_1_super_l_u_matrix.html" title="An thin interface to keep the main code insulated from the source code of SuperLU.">SuperLUMatrix</a> luMat (See <a class="el" href="class_p_e_x_s_i_1_1_super_l_u_matrix.html" title="An thin interface to keep the main code insulated from the source code of SuperLU.">SuperLUMatrix</a> for information on how to perform factorization), perform the following steps for parallel selected inversion.</p>
<ul>
<li><p class="startli">Conversion from SuperLU_DIST.</p>
<p class="startli">Symbolic information </p><pre class="fragment">SuperNodeType super; 
PMatrix PMloc;
luMat.SymbolicToSuperNode( super );  
</pre><p class="startli">Numerical information, both L and U. </p><pre class="fragment">luMat.LUstructToPMatrix( PMloc ); 
</pre></li>
<li><p class="startli">Preparation.</p>
<p class="startli">Construct the communication pattern for SelInv. </p><pre class="fragment">PMloc.ConstructCommunicationPattern(); 
or PMloc.ConstructCommunicationPattern_P2p(); 
or PMloc.ConstructCommunicationPattern_Collectives(); 
</pre><p class="startli">Numerical preparation so that SelInv only involves Gemm. </p><pre class="fragment">PMloc.PreSelInv();  
</pre></li>
<li>Selected inversion. <pre class="fragment">PMloc.SelInv();
or PMloc.SelInv_P2p();
or PMloc.SelInv_Collectives();
</pre></li>
<li><p class="startli">Postprocessing.</p>
<p class="startli">Get the information in <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a> format </p><pre class="fragment">DistSparseMatrix&lt;Scalar&gt; Ainv;
PMloc.PMatrixToDistSparseMatrix( Ainv );  
</pre></li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Note</h2>
<ul>
<li>All major operations of <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a>, including the selected inversion are defined directly as the member function of <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a>.</li>
<li>In the current version of <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a>, square grid is assumed. This assumption is only used when sending the information to cross-diagonal blocks, i.e. from L(isup, ksup) to U(ksup, isup). This assumption can be relaxed later. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad3df0961e1a11d9a5f53f4950f996f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3df0961e1a11d9a5f53f4950f996f84">&#9670;&nbsp;</a></span>GetDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PEXSI::PMatrix</a>&lt; T &gt;::GetDiagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">NumVec</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>diag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GetDiagonal extracts the diagonal elements of the <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a>. </p>
<p>1) diag is permuted back to the natural order</p>
<p>2) diag is shared by all processors in grid_-&gt;comm through a Allreduce procedure. </p>

</div>
</div>
<a id="a5264f2c2fb65d66882609dc4e29192e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5264f2c2fb65d66882609dc4e29192e9">&#9670;&nbsp;</a></span>PMatrixToDistSparseMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PEXSI::PMatrix</a>&lt; T &gt;::PMatrixToDistSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PMatrixToDistSparseMatrix converts the <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a> into a distributed compressed sparse column matrix format B, which has the same sparsity pattern as the <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a> A. </p>
<p>The <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a> follows the natural order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input sparse matrix to provide the sparsity pattern.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>Output sparse matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22d190f3a20b58173cff10aa95a89bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d190f3a20b58173cff10aa95a89bd1">&#9670;&nbsp;</a></span>PMatrixToDistSparseMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PEXSI::PMatrix</a>&lt; T &gt;::PMatrixToDistSparseMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PMatrixToDistSparseMatrix converts the <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a> into a distributed compressed sparse column matrix format. The <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a> follows the natural order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Output sparse matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a869d3f7ef697dc77091ce224882b1ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869d3f7ef697dc77091ce224882b1ab0">&#9670;&nbsp;</a></span>PMatrixToDistSparseMatrix_OLD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PEXSI::PMatrix</a>&lt; T &gt;::PMatrixToDistSparseMatrix_OLD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PMatrixToDistSparseMatrix_OLD converts the <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html" title="PMatrix contains the main data structure and the computational routine for the parallel selected inve...">PMatrix</a> into a distributed compressed sparse column matrix format B, which has the same sparsity pattern as the <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a> A. </p>
<p>The <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html" title="DistSparseMatrix describes a Sparse matrix in the compressed sparse column format (CSC) and distribut...">DistSparseMatrix</a> follows the natural order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input sparse matrix to provide the sparsity pattern.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>Output sparse matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5881204ac3a6b2807b88657727635208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5881204ac3a6b2807b88657727635208">&#9670;&nbsp;</a></span>PreSelInv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PEXSI::PMatrix</a>&lt; T &gt;::PreSelInv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PreSelInv prepares the structure in L_ and U_ so that SelInv only involves matrix-matrix multiplication. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Move documentation to a more proper place and update the information.</dd></dl>
<h2><a class="anchor" id="autotoc_md4"></a>
Procedure</h2>
<p>PreSelInv performs</p>
<ul>
<li><p class="startli">Compute the inverse of the diagonal blocks</p>
<p class="startli">L_{kk} &lt;- (L_{kk} U_{kk})^{-1}</p>
</li>
<li><p class="startli">Update the lower triangular L blocks</p>
<p class="startli">L_{ik} &lt;- L_{ik} L_{kk}^{-1}</p>
</li>
<li><p class="startli">Update the upper triangular U blocks which saves redundant information as in L</p>
<p class="startli">U_{kj} &lt;- L_{ik}</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Note</h2>
<p>PreSelInv assumes that <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a9ab522c5b09ef23435a1292a1be1074f" title="ConstructCommunicationPattern constructs the communication pattern to be used later in the selected i...">PEXSI::PMatrix::ConstructCommunicationPattern</a> has been executed. </p>

</div>
</div>
<a id="a6b608a2b05cb1ef1c20e0767bc5f81db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b608a2b05cb1ef1c20e0767bc5f81db">&#9670;&nbsp;</a></span>SelInv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html">PEXSI::PMatrix</a>&lt; T &gt;::SelInv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SelInv is the main function for the selected inversion. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Move documentation to a more proper place and update the information.</dd></dl>
<h2><a class="anchor" id="autotoc_md6"></a>
Procedure</h2>
<p>PSelInv is a right-looking based parallel selected inversion subroutine for sparse symmetric matrices. Static pivoting is used in this version.</p>
<p>Although the matrix is symmetric, the key idea of the current implementation of PSelInv is that the upper-triangular matrix is saved (in the form of <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html" title="UBlock stores a nonzero block in the upper triangular part in PSelInv.">UBlock</a>). Such redundant information is effective for reducing the complexity for designing the communication pattern. <br  />
</p>
<p>At each supernode ksup, the lower triangular part Ainv(isup, ksup) (isup &gt; ksup) are first updated. The blocks in the processor row of ksup first sends the nonzero blocks in U(ksup, jsup) (which is L(isup, ksup)^T) to the Schur complements Ainv(isup, jsup). At the same time the blocks in the processor column of ksup sends the nonzero blocks (only nonzero row indices) to the Schur complement Ainv(isup, jsup). Then</p>
<p>sum_{jsup} Ainv(isup, jsup) U^{T}(ksup, jsup)</p>
<p>is performed. In this procedure, only processors with isRecvFromAbove[ksup] == true &amp;&amp; isRecvFromLeft[ksup] == true participate in the computation.</p>
<p>The result is reduced to the processor column ksup within the same processor row. The diagonal block Ainv(ksup, ksup) is simply updated by a reduce procedure within the column processor group of ksup.</p>
<p>Then we update the Ainv(ksup, isup) blocks, simply via the update from the cross diagonal processors.</p>
<p><b> NOTE </b>: The cross diagonal processor is only well here defined for square grids. For a P x P square grid, (ip, jp) is the cross diagonal processor of (jp, ip) if ip != jp. The current version of SelInv only works for square processor grids.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Communication pattern</h2>
<p>The communication is controlled by 3 sending varaibles and 3 receiving variables. The first dimension of all the sending and receiving variables are numSuper. The information contains redundancy since not all processors have access to all the supernodes. However, this increases the readability of the output significantly and only increases a small amount of memory cost for indexing. This set of sending / receiving mechanism avoids the double indexing of the supernodes and can scale to matrices of large size.</p>
<ul>
<li><p class="startli">isSendToBelow: <br  />
</p>
<p class="startli">Dimension: numSuper x numProcRow</p>
<p class="startli">Role : At supernode ksup, if isSendToBelow(ksup, ip) == true, send all local blocks {U(ksup, jsup) | jsup &gt; ksup} to the processor row ip.</p>
</li>
<li><p class="startli">isRecvFromAbove:</p>
<p class="startli">Dimension: numSuper</p>
<p class="startli">Role :</p><ul>
<li>At supernode ksup, if isRecvFromAbove(ksup) == true, receive blocks from the processor owning the block row of ksup within the same column processor group.</li>
<li>If isRecvFromAbove(ksup) == true &amp;&amp; isRecvFromLeft(ksup) == true, the ucrrent processor participate in updating Ainv(isup, ksup).</li>
</ul>
</li>
<li><p class="startli">isSendToRight:</p>
<p class="startli">Dimension: numSuper x numProcCol</p>
<p class="startli">Role : At supernode ksup, if isSendToRight(ksup, jp) == true, send all local blocks (mainly the nonzero row indicies, without the values to save the communication cost) {L(isup, ksup) | isup &gt; ksup} to the processor column jp.</p>
</li>
<li><p class="startli">isRecvFromLeft:</p>
<p class="startli">Dimension: numSuper</p>
<p class="startli">Role :</p><ul>
<li>At supernode ksup, if isRecvFromLeft(ksup) == true, receive blocks from the processor owning the block column of ksup within the same row processor group.</li>
<li>If isRecvFromAbove(ksup) == true &amp;&amp; isRecvFromLeft(ksup) == true, the ucrrent processor participate in updating Ainv(isup, ksup).</li>
</ul>
</li>
<li><p class="startli">isSendToCrossDiagonal:</p>
<p class="startli">Dimension: numSuper</p>
<p class="startli">Role : At supernode ksup, if isSendToCrossDiagonal(ksup) == true, send all local blocks {(isup, ksup) | isup &gt; ksup} to the cross-diagonal processor. <b> NOTE </b>: This requires a square processor grid.</p>
</li>
<li><p class="startli">isRecvCrossDiagonal:</p>
<p class="startli">Dimension: numSuper</p>
<p class="startli">Role : At supernode ksup, if isRecvFromCrossDiagonal(ksup) == true, receive from the cross-diagonal processor. <b> NOTE </b>: This requires a square processor grid. </p>
</li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pexsi/<a class="el" href="pselinv_8hpp_source.html">pselinv.hpp</a></li>
<li>include/pexsi/<a class="el" href="pselinv__impl_8hpp_source.html">pselinv_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 1 2022 20:34:01 for PEXSI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
