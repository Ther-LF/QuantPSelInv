<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PEXSI: PEXSI::PMatrixUnsym Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://math.berkeley.edu/~linlin/MathJax-2.6/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PEXSI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_p_e_x_s_i.html">PEXSI</a></li><li class="navelem"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html">PMatrixUnsym</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_p_e_x_s_i_1_1_p_matrix_unsym-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PEXSI::PMatrixUnsym Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html" title="PMatrixUnsym contains the main data structure and the computational routine for the parallel selected...">PMatrixUnsym</a> contains the main data structure and the computational routine for the parallel selected inversion. <br  />
  
 <a href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pselinv__unsym_8hpp_source.html">pselinv_unsym.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_unsym_1_1_super_node_buffer_type_unsym.html">SuperNodeBufferTypeUnsym</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b3dcaa2656f8d8129c0b9fe0a0f55b1"><td class="memItemLeft" align="right" valign="top"><a id="a1b3dcaa2656f8d8129c0b9fe0a0f55b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PMatrixUnsym</b> (const <a class="el" href="struct_p_e_x_s_i_1_1_grid_type.html">GridType</a> *g, const <a class="el" href="struct_p_e_x_s_i_1_1_super_node_type.html">SuperNodeType</a> *s, const <a class="el" href="struct_p_e_x_s_i_1_1_p_sel_inv_options.html">PSelInvOptions</a> *o, const <a class="el" href="struct_p_e_x_s_i_1_1_factorization_options.html">FactorizationOptions</a> *oFact)</td></tr>
<tr class="separator:a1b3dcaa2656f8d8129c0b9fe0a0f55b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b67853942169036a7b88a64878f1ed"><td class="memItemLeft" align="right" valign="top"><a id="a96b67853942169036a7b88a64878f1ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Setup</b> (const <a class="el" href="struct_p_e_x_s_i_1_1_grid_type.html">GridType</a> *g, const <a class="el" href="struct_p_e_x_s_i_1_1_super_node_type.html">SuperNodeType</a> *s, const <a class="el" href="struct_p_e_x_s_i_1_1_p_sel_inv_options.html">PSelInvOptions</a> *o, const <a class="el" href="struct_p_e_x_s_i_1_1_factorization_options.html">FactorizationOptions</a> *oFact)</td></tr>
<tr class="separator:a96b67853942169036a7b88a64878f1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44691a95074c7871ee0c5d379a98856"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#ad44691a95074c7871ee0c5d379a98856">Lrow</a> (Int iLocal)</td></tr>
<tr class="memdesc:ad44691a95074c7871ee0c5d379a98856"><td class="mdescLeft">&#160;</td><td class="mdescRight">NumBlockL returns the number of nonzero L blocks for the local block column jLocal.  <a href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#ad44691a95074c7871ee0c5d379a98856">More...</a><br /></td></tr>
<tr class="separator:ad44691a95074c7871ee0c5d379a98856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550f5ccb31857424e50ad9cc95b917a2"><td class="memItemLeft" align="right" valign="top"><a id="a550f5ccb31857424e50ad9cc95b917a2"></a>
std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#a550f5ccb31857424e50ad9cc95b917a2">Ucol</a> (Int jLocal)</td></tr>
<tr class="memdesc:a550f5ccb31857424e50ad9cc95b917a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ucol returns the vector of nonzero U blocks for the local block col jLocal. <br /></td></tr>
<tr class="separator:a550f5ccb31857424e50ad9cc95b917a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc0df2afd192d73d05e95e813903c8a"><td class="memItemLeft" align="right" valign="top"><a id="adcc0df2afd192d73d05e95e813903c8a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#adcc0df2afd192d73d05e95e813903c8a">ConstructCommunicationPattern</a> ()</td></tr>
<tr class="memdesc:adcc0df2afd192d73d05e95e813903c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConstructCommunicationPattern constructs the communication pattern to be used later in the selected inversion stage. The supernodal elimination tree is used to add an additional level of parallelism between supernodes. <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#ab3fb44f9da5a32e6baae98fa8519045d">ConstructCommunicationPattern_P2p</a> is called by default. <br /></td></tr>
<tr class="separator:adcc0df2afd192d73d05e95e813903c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af678b3565322c608ea379adc261b537f"><td class="memItemLeft" align="right" valign="top"><a id="af678b3565322c608ea379adc261b537f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#af678b3565322c608ea379adc261b537f">ConstructCommunicationPattern_P2p</a> ()</td></tr>
<tr class="memdesc:af678b3565322c608ea379adc261b537f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConstructCommunicationPattern_P2p constructs the communication pattern to be used later in the selected inversion stage. The supernodal elimination tree is used to add an additional level of parallelism between supernodes. <br /></td></tr>
<tr class="separator:af678b3565322c608ea379adc261b537f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9255151051493ff75d17320b0c6668"><td class="memItemLeft" align="right" valign="top"><a id="a3e9255151051493ff75d17320b0c6668"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConstructCommunicationPattern_New</b> ()</td></tr>
<tr class="separator:a3e9255151051493ff75d17320b0c6668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d423e9c0ad0113297ad90fad2fa7bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#a17d423e9c0ad0113297ad90fad2fa7bc">PreSelInv</a> ()</td></tr>
<tr class="memdesc:a17d423e9c0ad0113297ad90fad2fa7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PreSelInv prepares the structure in L_ and U_ so that SelInv only involves matrix-matrix multiplication.  <a href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#a17d423e9c0ad0113297ad90fad2fa7bc">More...</a><br /></td></tr>
<tr class="separator:a17d423e9c0ad0113297ad90fad2fa7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2609f1de294a4003961f776034bccad9"><td class="memItemLeft" align="right" valign="top"><a id="a2609f1de294a4003961f776034bccad9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>PreSelInv_New</b> ()</td></tr>
<tr class="separator:a2609f1de294a4003961f776034bccad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b210f188e4ef8bac334f51a5969ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#a9c9b210f188e4ef8bac334f51a5969ef">SelInv</a> ()</td></tr>
<tr class="memdesc:a9c9b210f188e4ef8bac334f51a5969ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">SelInv is the main function for the selected inversion.  <a href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#a9c9b210f188e4ef8bac334f51a5969ef">More...</a><br /></td></tr>
<tr class="separator:a9c9b210f188e4ef8bac334f51a5969ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1e5c9dca21a7ad9e1925ccfebc7e7a"><td class="memItemLeft" align="right" valign="top"><a id="aec1e5c9dca21a7ad9e1925ccfebc7e7a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#aec1e5c9dca21a7ad9e1925ccfebc7e7a">SelInv_P2p</a> ()</td></tr>
<tr class="memdesc:aec1e5c9dca21a7ad9e1925ccfebc7e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-to-point version of the selected inversion. <br /></td></tr>
<tr class="separator:aec1e5c9dca21a7ad9e1925ccfebc7e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ab416f6ee13196c640fff60a6bf836898"><td class="memItemLeft" align="right" valign="top"><a id="ab416f6ee13196c640fff60a6bf836898"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>SELINV_TAG_U_SIZE</b>, 
<b>SELINV_TAG_U_CONTENT</b>, 
<b>SELINV_TAG_L_SIZE</b>, 
<b>SELINV_TAG_L_CONTENT</b>, 
<br />
&#160;&#160;<b>SELINV_TAG_UCOL_SIZE</b>, 
<b>SELINV_TAG_UCOL_CONTENT</b>, 
<b>SELINV_TAG_LROW_SIZE</b>, 
<b>SELINV_TAG_LROW_CONTENT</b>, 
<br />
&#160;&#160;<b>SELINV_TAG_L_REDUCE</b>, 
<b>SELINV_TAG_U_REDUCE</b>, 
<b>SELINV_TAG_D_SIZE</b>, 
<b>SELINV_TAG_D_CONTENT</b>, 
<br />
&#160;&#160;<b>SELINV_TAG_D_REDUCE</b>, 
<b>SELINV_TAG_U_SIZE_CD</b>, 
<b>SELINV_TAG_U_CONTENT_CD</b>, 
<b>SELINV_TAG_L_SIZE_CD</b>, 
<br />
&#160;&#160;<b>SELINV_TAG_L_CONTENT_CD</b>, 
<b>SELINV_TAG_COUNT</b>
<br />
 }</td></tr>
<tr class="separator:ab416f6ee13196c640fff60a6bf836898"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a22b44619e5858770cb45d11b80004ddf"><td class="memItemLeft" align="right" valign="top"><a id="a22b44619e5858770cb45d11b80004ddf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>PMatrixToDistSparseMatrix_</b> (const <a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">NumVec</a>&lt; Int &gt; &amp;AcolptrLocal, const <a class="el" href="class_p_e_x_s_i_1_1_num_vec.html">NumVec</a>&lt; Int &gt; &amp;ArowindLocal, const Int Asize, const LongInt Annz, const Int AnnzLocal, <a class="el" href="struct_p_e_x_s_i_1_1_dist_sparse_matrix.html">DistSparseMatrix</a>&lt; T &gt; &amp;B)</td></tr>
<tr class="separator:a22b44619e5858770cb45d11b80004ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8886a471f273f213f9b61e00cf4f230"><td class="memItemLeft" align="right" valign="top"><a id="ab8886a471f273f213f9b61e00cf4f230"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#ab8886a471f273f213f9b61e00cf4f230">SelInvIntra_P2p</a> (Int lidx)</td></tr>
<tr class="memdesc:ab8886a471f273f213f9b61e00cf4f230"><td class="mdescLeft">&#160;</td><td class="mdescRight">SelInvIntra_P2p. <br /></td></tr>
<tr class="separator:ab8886a471f273f213f9b61e00cf4f230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d582cd5679b608046958eb67659183"><td class="memItemLeft" align="right" valign="top"><a id="a05d582cd5679b608046958eb67659183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SelInvIntra_New</b> (Int lidx, Int &amp;rank)</td></tr>
<tr class="separator:a05d582cd5679b608046958eb67659183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ad12a96f0e283eed3dba98013416c"><td class="memItemLeft" align="right" valign="top"><a id="a4a2ad12a96f0e283eed3dba98013416c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#a4a2ad12a96f0e283eed3dba98013416c">SelInv_lookup_indexes</a> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_unsym_1_1_super_node_buffer_type_unsym.html">SuperNodeBufferTypeUnsym</a> &amp;snode, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;LcolRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;LrowRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;UcolRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;UrowRecv, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;AinvBuf, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;LBuf, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;UBuf)</td></tr>
<tr class="memdesc:a4a2ad12a96f0e283eed3dba98013416c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SelInv_lookup_indexes. <br /></td></tr>
<tr class="separator:a4a2ad12a96f0e283eed3dba98013416c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae08b0d3b73b24618b10c96257fc707"><td class="memItemLeft" align="right" valign="top"><a id="a3ae08b0d3b73b24618b10c96257fc707"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SelInv_lookup_indexes_New</b> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_unsym_1_1_super_node_buffer_type_unsym.html">SuperNodeBufferTypeUnsym</a> &amp;snode, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;LRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;URecv, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;AinvBuf, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;LBuf, <a class="el" href="class_p_e_x_s_i_1_1_num_mat.html">NumMat</a>&lt; T &gt; &amp;UBuf)</td></tr>
<tr class="separator:a3ae08b0d3b73b24618b10c96257fc707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55f81ef4f4e8a62ea7cf26aa2cb5cc4"><td class="memItemLeft" align="right" valign="top"><a id="ae55f81ef4f4e8a62ea7cf26aa2cb5cc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#ae55f81ef4f4e8a62ea7cf26aa2cb5cc4">UnpackData</a> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_unsym_1_1_super_node_buffer_type_unsym.html">SuperNodeBufferTypeUnsym</a> &amp;snode, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;LcolRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;LrowRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;UcolRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;UrowRecv)</td></tr>
<tr class="memdesc:ae55f81ef4f4e8a62ea7cf26aa2cb5cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnpackData. <br /></td></tr>
<tr class="separator:ae55f81ef4f4e8a62ea7cf26aa2cb5cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90717da3f7530b54769a6a5abc677721"><td class="memItemLeft" align="right" valign="top"><a id="a90717da3f7530b54769a6a5abc677721"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnpackData_New</b> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_unsym_1_1_super_node_buffer_type_unsym.html">SuperNodeBufferTypeUnsym</a> &amp;snode, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &amp;LRecv, std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &amp;URecv)</td></tr>
<tr class="separator:a90717da3f7530b54769a6a5abc677721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a3f007359715719b27cc5332dea561"><td class="memItemLeft" align="right" valign="top"><a id="ae5a3f007359715719b27cc5332dea561"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#ae5a3f007359715719b27cc5332dea561">ComputeDiagUpdate</a> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_unsym_1_1_super_node_buffer_type_unsym.html">SuperNodeBufferTypeUnsym</a> &amp;snode)</td></tr>
<tr class="memdesc:ae5a3f007359715719b27cc5332dea561"><td class="mdescLeft">&#160;</td><td class="mdescRight">ComputeDiagUpdate. <br /></td></tr>
<tr class="separator:ae5a3f007359715719b27cc5332dea561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8882e7e38857395732739c29411b69e"><td class="memItemLeft" align="right" valign="top"><a id="af8882e7e38857395732739c29411b69e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeDiagUpdate_New</b> (<a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_unsym_1_1_super_node_buffer_type_unsym.html">SuperNodeBufferTypeUnsym</a> &amp;snode, bool fromU)</td></tr>
<tr class="separator:af8882e7e38857395732739c29411b69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4503d1cc6322221754c86ab889cf52"><td class="memItemLeft" align="right" valign="top"><a id="a3c4503d1cc6322221754c86ab889cf52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html#a3c4503d1cc6322221754c86ab889cf52">SendRecvCD</a> (std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_p_matrix_unsym_1_1_super_node_buffer_type_unsym.html">SuperNodeBufferTypeUnsym</a> &gt; &amp;arrSuperNodes, Int stepSuper)</td></tr>
<tr class="memdesc:a3c4503d1cc6322221754c86ab889cf52"><td class="mdescLeft">&#160;</td><td class="mdescRight">SendRecvCD_UpdateU. <br /></td></tr>
<tr class="separator:a3c4503d1cc6322221754c86ab889cf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228f58156f485bd6424789214480040a"><td class="memItemLeft" align="right" valign="top"><a id="a228f58156f485bd6424789214480040a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SendRecvSizesCD</b> (std::vector&lt; Int &gt; &amp;arrSuperNodes, Int stepSuper, <a class="el" href="struct_p_e_x_s_i_1_1_c_d_buffers.html">CDBuffers</a> &amp;buffers)</td></tr>
<tr class="separator:a228f58156f485bd6424789214480040a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d336cc2a27fe6ca796646b30ba291f"><td class="memItemLeft" align="right" valign="top"><a id="a78d336cc2a27fe6ca796646b30ba291f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IRecvContentCD</b> (std::vector&lt; Int &gt; &amp;arrSuperNodes, Int stepSuper, <a class="el" href="struct_p_e_x_s_i_1_1_c_d_buffers.html">CDBuffers</a> &amp;buffers)</td></tr>
<tr class="separator:a78d336cc2a27fe6ca796646b30ba291f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78747295b6e2de88150ae4441a611b47"><td class="memItemLeft" align="right" valign="top"><a id="a78747295b6e2de88150ae4441a611b47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WaitContentLCD</b> (std::vector&lt; Int &gt; &amp;arrSuperNodes, Int stepSuper, <a class="el" href="struct_p_e_x_s_i_1_1_c_d_buffers.html">CDBuffers</a> &amp;buffers)</td></tr>
<tr class="separator:a78747295b6e2de88150ae4441a611b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2206bf7975d00bcd66f69f10b3114200"><td class="memItemLeft" align="right" valign="top"><a id="a2206bf7975d00bcd66f69f10b3114200"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WaitContentUCD</b> (std::vector&lt; Int &gt; &amp;arrSuperNodes, Int stepSuper, <a class="el" href="struct_p_e_x_s_i_1_1_c_d_buffers.html">CDBuffers</a> &amp;buffers)</td></tr>
<tr class="separator:a2206bf7975d00bcd66f69f10b3114200"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a24836bf62a3311f68a017cdee487d21d"><td class="memItemLeft" align="right" valign="top"><a id="a24836bf62a3311f68a017cdee487d21d"></a>
std::vector&lt; std::vector&lt; Int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>isSendToCD_</b></td></tr>
<tr class="separator:a24836bf62a3311f68a017cdee487d21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08e561d3dc2c637688d6a0457741120"><td class="memItemLeft" align="right" valign="top"><a id="ad08e561d3dc2c637688d6a0457741120"></a>
std::vector&lt; std::vector&lt; Int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>isRecvFromCD_</b></td></tr>
<tr class="separator:ad08e561d3dc2c637688d6a0457741120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f0a05e17b2363efbaa6f20d8c143b"><td class="memItemLeft" align="right" valign="top"><a id="abc4f0a05e17b2363efbaa6f20d8c143b"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_bcast__v2.html">TreeBcast_v2</a>&lt; char &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bcastLStructTree_</b></td></tr>
<tr class="separator:abc4f0a05e17b2363efbaa6f20d8c143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5357a1c3dabd988854872a9af6cb315d"><td class="memItemLeft" align="right" valign="top"><a id="a5357a1c3dabd988854872a9af6cb315d"></a>
std::vector&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_bcast__v2.html">TreeBcast_v2</a>&lt; char &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bcastUDataTrees_</b></td></tr>
<tr class="separator:a5357a1c3dabd988854872a9af6cb315d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada14d2b3c67e2c5cc12b70542a7c2c15"><td class="memItemLeft" align="right" valign="top"><a id="ada14d2b3c67e2c5cc12b70542a7c2c15"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_bcast__v2.html">TreeBcast_v2</a>&lt; char &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bcastUDataTree_</b></td></tr>
<tr class="separator:ada14d2b3c67e2c5cc12b70542a7c2c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5637d8168c51948019ac9917572d53"><td class="memItemLeft" align="right" valign="top"><a id="a4e5637d8168c51948019ac9917572d53"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_bcast__v2.html">TreeBcast_v2</a>&lt; char &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bcastUStructTree_</b></td></tr>
<tr class="separator:a4e5637d8168c51948019ac9917572d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfee8ea83ce6ff6e1cdba3b8cb3c6db"><td class="memItemLeft" align="right" valign="top"><a id="accfee8ea83ce6ff6e1cdba3b8cb3c6db"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_reduce__v2.html">TreeReduce_v2</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>redUTree2_</b></td></tr>
<tr class="separator:accfee8ea83ce6ff6e1cdba3b8cb3c6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9d36191e1c890d0313d10767ff3723"><td class="memItemLeft" align="right" valign="top"><a id="a8f9d36191e1c890d0313d10767ff3723"></a>
std::vector&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_reduce.html">TreeReduce</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>redLTree_</b></td></tr>
<tr class="separator:a8f9d36191e1c890d0313d10767ff3723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13895a03bdc58ae42c6eb77bcf93646"><td class="memItemLeft" align="right" valign="top"><a id="af13895a03bdc58ae42c6eb77bcf93646"></a>
std::vector&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_reduce.html">TreeReduce</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>redDTree_</b></td></tr>
<tr class="separator:af13895a03bdc58ae42c6eb77bcf93646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eef3822a8729edea4a9fc5f520387dd"><td class="memItemLeft" align="right" valign="top"><a id="a7eef3822a8729edea4a9fc5f520387dd"></a>
std::vector&lt; <a class="el" href="class_p_e_x_s_i_1_1_tree_reduce.html">TreeReduce</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>redUTree_</b></td></tr>
<tr class="separator:a7eef3822a8729edea4a9fc5f520387dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0621f1ebfedf716262beb1a4618bd8"><td class="memItemLeft" align="right" valign="top"><a id="adb0621f1ebfedf716262beb1a4618bd8"></a>
std::vector&lt; std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_u_block.html">UBlock</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ucol_</b></td></tr>
<tr class="separator:adb0621f1ebfedf716262beb1a4618bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5520161fa326fbd162307c9899b52ab1"><td class="memItemLeft" align="right" valign="top"><a id="a5520161fa326fbd162307c9899b52ab1"></a>
std::vector&lt; std::vector&lt; <a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Lrow_</b></td></tr>
<tr class="separator:a5520161fa326fbd162307c9899b52ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e55fdcea25719d86c0048aa4ef6dfd"><td class="memItemLeft" align="right" valign="top"><a id="a00e55fdcea25719d86c0048aa4ef6dfd"></a>
std::vector&lt; Int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>UcolSize_</b></td></tr>
<tr class="separator:a00e55fdcea25719d86c0048aa4ef6dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a54d8e4a573c5dd7d30d28753a721a4"><td class="memItemLeft" align="right" valign="top"><a id="a5a54d8e4a573c5dd7d30d28753a721a4"></a>
std::vector&lt; Int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LrowSize_</b></td></tr>
<tr class="separator:a5a54d8e4a573c5dd7d30d28753a721a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_p_e_x_s_i_1_1_p_matrix_unsym.html" title="PMatrixUnsym contains the main data structure and the computational routine for the parallel selected...">PMatrixUnsym</a> contains the main data structure and the computational routine for the parallel selected inversion. <br  />
 </p>
<p><b>NOTE</b></p>
<p>For general non-symmetric matrices, the selected elements are :math:<code>\{B_{i,j}\vert A_{j,i}\ne 0\}</code>. This means that the matrix elements computed corresponding to the sparsity pattern of :math:<code>A^T</code> (for more detailed explanation of the mathematical reason, please see the paper :ref:<code>PC2018 &lt;citeNonSymPSelInv&gt;</code> in the <a class="el" href="namespace_p_e_x_s_i.html" title="The main namespace.">PEXSI</a> documentation). However, storing the matrix elements :math:<code>\{A^{-1}_{i,j}\vert A_{j,i}\ne 0\}</code> is practically cumbersome, especially in the context of distributed computing. Hence we choose to store the selected elements for :math:<code>A^{-T}</code>, i.e. :math:<code>\{A^{-T}_{i,j}\vert A_{i,j}\ne 0\}</code>. These are the values obtained from the non-symmetric version of PSelInv. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad44691a95074c7871ee0c5d379a98856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44691a95074c7871ee0c5d379a98856">&#9670;&nbsp;</a></span>Lrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_p_e_x_s_i_1_1_l_block.html">LBlock</a>&lt;T&gt; &gt;&amp; PEXSI::PMatrixUnsym::Lrow </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>iLocal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NumBlockL returns the number of nonzero L blocks for the local block column jLocal. </p>
<p>NumBlockU returns the number of nonzero U blocks for the local block row iLocal.</p>
<p>Lrow returns the vector of nonzero L blocks for the local block row iLocal. </p>

</div>
</div>
<a id="a17d423e9c0ad0113297ad90fad2fa7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d423e9c0ad0113297ad90fad2fa7bc">&#9670;&nbsp;</a></span>PreSelInv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PMatrixUnsym::PreSelInv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PreSelInv prepares the structure in L_ and U_ so that SelInv only involves matrix-matrix multiplication. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Move documentation to a more proper place and update the information.</dd></dl>
<h2><a class="anchor" id="autotoc_md8"></a>
Procedure</h2>
<p>PreSelInv performs</p>
<ul>
<li><p class="startli">Compute the inverse of the diagonal blocks</p>
<p class="startli">L_{kk} &lt;- (L_{kk} U_{kk})^{-1}</p>
</li>
<li><p class="startli">Update the lower triangular L blocks</p>
<p class="startli">L_{ik} &lt;- L_{ik} L_{kk}^{-1}</p>
</li>
<li><p class="startli">Update the upper triangular U blocks which saves redundant information as in L</p>
<p class="startli">U_{kj} &lt;- L_{ik}</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
Note</h2>
<p>PreSelInv assumes that <a class="el" href="class_p_e_x_s_i_1_1_p_matrix.html#a9ab522c5b09ef23435a1292a1be1074f" title="ConstructCommunicationPattern constructs the communication pattern to be used later in the selected i...">PEXSI::PMatrix::ConstructCommunicationPattern</a> has been executed. </p>

</div>
</div>
<a id="a9c9b210f188e4ef8bac334f51a5969ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9b210f188e4ef8bac334f51a5969ef">&#9670;&nbsp;</a></span>SelInv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PEXSI::PMatrixUnsym::SelInv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SelInv is the main function for the selected inversion. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Move documentation to a more proper place and update the information.</dd></dl>
<h2><a class="anchor" id="autotoc_md10"></a>
Procedure</h2>
<p>PSelInv is a right-looking based parallel selected inversion subroutine for sparse matrices. Static pivoting is used in this version.</p>
<p>At each supernode ksup, the lower triangular part Ainv(isup, ksup) (isup &gt; ksup) are first updated. The blocks in the processor row of ksup first sends the nonzero blocks in U(ksup, jsup) (which is L(isup, ksup)^T) to the Schur complements Ainv(isup, jsup). At the same time the blocks in the processor column of ksup sends the nonzero blocks (only nonzero row indices) to the Schur complement Ainv(isup, jsup). Then</p>
<p>sum_{jsup} Ainv(isup, jsup) U^{T}(ksup, jsup)</p>
<p>is performed. In this procedure, only processors with isRecvFromAbove[ksup] == true &amp;&amp; isRecvFromLeft[ksup] == true participate in the computation.</p>
<p>The result is reduced to the processor column ksup within the same processor row. The diagonal block Ainv(ksup, ksup) is simply updated by a reduce procedure within the column processor group of ksup.</p>
<p>Then we update the Ainv(ksup, isup) blocks, simply via the update from the cross diagonal processors.</p>
<p><b> NOTE </b>: The cross diagonal processor is only well here defined for square grids. For a P x P square grid, (ip, jp) is the cross diagonal processor of (jp, ip) if ip != jp. The current version of SelInv only works for square processor grids.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Communication pattern</h2>
<p>The communication is controlled by 3 sending varaibles and 3 receiving variables. The first dimension of all the sending and receiving variables are numSuper. The information contains redundancy since not all processors have access to all the supernodes. However, this increases the readability of the output significantly and only increases a small amount of memory cost for indexing. This set of sending / receiving mechanism avoids the double indexing of the supernodes and can scale to matrices of large size.</p>
<ul>
<li><p class="startli">isSendToBelow: <br  />
</p>
<p class="startli">Dimension: numSuper x numProcRow</p>
<p class="startli">Role : At supernode ksup, if isSendToBelow(ksup, ip) == true, send all local blocks {U(ksup, jsup) | jsup &gt; ksup} to the processor row ip.</p>
</li>
<li><p class="startli">isRecvFromAbove:</p>
<p class="startli">Dimension: numSuper</p>
<p class="startli">Role :</p><ul>
<li>At supernode ksup, if isRecvFromAbove(ksup) == true, receive blocks from the processor owning the block row of ksup within the same column processor group.</li>
<li>If isRecvFromAbove(ksup) == true &amp;&amp; isRecvFromLeft(ksup) == true, the ucrrent processor participate in updating Ainv(isup, ksup).</li>
</ul>
</li>
<li><p class="startli">isSendToRight:</p>
<p class="startli">Dimension: numSuper x numProcCol</p>
<p class="startli">Role : At supernode ksup, if isSendToRight(ksup, jp) == true, send all local blocks (mainly the nonzero row indicies, without the values to save the communication cost) {L(isup, ksup) | isup &gt; ksup} to the processor column jp.</p>
</li>
<li><p class="startli">isRecvFromLeft:</p>
<p class="startli">Dimension: numSuper</p>
<p class="startli">Role :</p><ul>
<li>At supernode ksup, if isRecvFromLeft(ksup) == true, receive blocks from the processor owning the block column of ksup within the same row processor group.</li>
<li>If isRecvFromAbove(ksup) == true &amp;&amp; isRecvFromLeft(ksup) == true, the ucrrent processor participate in updating Ainv(isup, ksup).</li>
</ul>
</li>
<li><p class="startli">isSendToCrossDiagonal:</p>
<p class="startli">Dimension: numSuper</p>
<p class="startli">Role : At supernode ksup, if isSendToCrossDiagonal(ksup) == true, send all local blocks {(isup, ksup) | isup &gt; ksup} to the cross-diagonal processor. <b> NOTE </b>: This requires a square processor grid.</p>
</li>
<li><p class="startli">isRecvCrossDiagonal:</p>
<p class="startli">Dimension: numSuper</p>
<p class="startli">Role : At supernode ksup, if isRecvFromCrossDiagonal(ksup) == true, receive from the cross-diagonal processor. <b> NOTE </b>: This requires a square processor grid. </p>
</li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pexsi/<a class="el" href="pselinv_8hpp_source.html">pselinv.hpp</a></li>
<li>include/pexsi/<a class="el" href="pselinv__unsym_8hpp_source.html">pselinv_unsym.hpp</a></li>
<li>include/pexsi/<a class="el" href="pselinv__unsym__impl_8hpp_source.html">pselinv_unsym_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 1 2022 20:34:01 for PEXSI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
